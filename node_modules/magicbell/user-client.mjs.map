{"version":3,"file":"user-client.mjs","sources":["../src/lib/utils.ts","../src/client/error.ts","../src/client/headers.ts","../src/client/log.ts","../src/client/options.ts","../src/client/telemetry.ts","../src/client/client.ts","../src/client/paginate.ts","../src/resources/listen.ts","../src/client/method.ts","../src/client/resource.ts","../src/user-resources/notification-preferences.ts","../src/user-resources/notifications.ts","../src/user-resources/push-subscriptions.ts","../src/user-resources/subscriptions.ts","../src/user-client.ts"],"sourcesContent":["export const hasOwn = (obj, prop) => obj && Object.prototype.hasOwnProperty.call(obj, prop);\n\nexport function isString(value) {\n  return typeof value === 'string';\n}\n\nexport function isBoolean(value) {\n  return typeof value === 'boolean';\n}\n\nexport function isArray(value) {\n  return Array.isArray(value);\n}\n\nexport function isStringArray(value) {\n  return Array.isArray(value) && value.every((x) => typeof x === 'string');\n}\n\nexport function isNumber(value) {\n  return typeof value === 'number';\n}\n\nexport function isObject(value) {\n  return value && typeof value === 'object';\n}\n\nexport function compact(obj: Record<string, unknown>, dropEmptyString = false) {\n  if (typeof obj !== 'object') {\n    throw new Error('Argument must be an object');\n  }\n\n  const result = {};\n  for (const key of Object.keys(obj)) {\n    if (obj[key] == null) continue;\n    if (dropEmptyString && obj[key] === '') continue;\n    result[key] = obj[key];\n  }\n\n  return result;\n}\n\nexport async function sleep(ms: number) {\n  return new Promise((resolve) => setTimeout(resolve, ms));\n}\n\nexport function joinAnd(...parts) {\n  if (parts.length <= 2) return parts.join(' and ');\n\n  const last = parts.slice(-1)[0];\n  const others = parts.slice(0, -1);\n  return [others.join(', '), last].join(', and ');\n}\n\nexport function joinOr(...parts) {\n  if (parts.length <= 2) return parts.join(' or ');\n\n  const last = parts.slice(-1)[0];\n  const others = parts.slice(0, -1);\n  return [others.join(', '), last].join(', or ');\n}\n\nexport function joinUrlSegments(...segments) {\n  return ['/', ...segments].join('/').replace(/\\/+/g, '/').replace(/\\/$/, '');\n}\n\nexport function tryParse(obj: unknown) {\n  try {\n    return JSON.parse(String(obj));\n  } catch {\n    return obj;\n  }\n}\n","'use strict';\n\nexport function createError(rawError: ErrorConfig) {\n  for (const field of ['code', 'type', 'status']) {\n    switch (rawError[field]) {\n      case 'user_identifier_not_provided':\n        return new AuthenticationError(rawError);\n      case 'invalid_request_error':\n        return new InvalidRequestError(rawError);\n      case 'api_error':\n        return new APIError(rawError);\n      case 'authentication_error':\n        return new AuthenticationError(rawError);\n      case 'rate_limit_error':\n        return new RateLimitError(rawError);\n      case 'idempotency_error':\n        return new IdempotencyError(rawError);\n      case 404:\n        return new NotFoundError(rawError);\n      case 422:\n        return new UserInputError(rawError);\n    }\n  }\n\n  return new UnknownError(rawError);\n}\n\ntype ErrorConfig = {\n  name: string;\n  type?: string;\n  code?: string;\n  docs_url?: string;\n  help_link?: string;\n  status?: number;\n  statusText?: string;\n  responseBody?: unknown;\n  message: string;\n  suggestion?: string;\n};\n\n/**\n * BaseError is the base error from which all other more specific errors derive.\n * Specifically for errors returned from REST API.\n */\nexport class MagicBellError extends Error {\n  /**\n   * The name of the error.\n   */\n  name: string;\n  /**\n   * The error message returned by the REST API.\n   */\n  message: string;\n  /**\n   * The type of the error.\n   */\n  type?: string;\n  /**\n   * The URL to the documentation for the error.\n   */\n  docsUrl?: string;\n  /**\n   * The error code returned by the REST API.\n   */\n  code?: string;\n  /**\n   * The HTTP status code returned by the REST API.\n   */\n  status?: number;\n  /**\n   * The HTTP status text returned by the REST API.\n   */\n  statusText?: string;\n  /**\n   * A suggestion on how to fix the error.\n   */\n  suggestion?: string;\n  /**\n   * The raw response body returned by the REST API.\n   */\n  responseBody?: unknown;\n\n  /**\n   * @deprecated - use docsUrl instead\n   */\n  get docs_url() {\n    return this.docsUrl;\n  }\n\n  constructor(raw: ErrorConfig) {\n    super(raw.message);\n    this.type = this.constructor.name;\n    this.name = 'MagicBellError';\n    this.code = raw.code;\n    this.status = raw.status;\n    this.statusText = raw.statusText;\n    this.responseBody = raw.responseBody;\n    this.message = raw.message;\n    this.suggestion = raw.suggestion;\n    this.docsUrl = raw.docs_url || raw.help_link;\n  }\n}\n\nexport class InvalidRequestError extends MagicBellError {}\nexport class UserInputError extends MagicBellError {}\nexport class APIError extends MagicBellError {}\nexport class AuthenticationError extends MagicBellError {}\nexport class PermissionError extends MagicBellError {}\nexport class RateLimitError extends MagicBellError {}\nexport class ConnectionError extends MagicBellError {}\nexport class IdempotencyError extends MagicBellError {}\nexport class UnknownError extends MagicBellError {}\nexport class NotFoundError extends MagicBellError {}\n","import { deleteEmptyHeaders } from 'fetch-addons';\nimport type { Hooks } from 'ky';\n\nimport { ClientOptions } from './types';\n\nfunction uuid4() {\n  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c) => {\n    const r = (Math.random() * 16) | 0;\n    const v = c === 'x' ? r : (r & 0x3) | 0x8;\n    return v.toString(16);\n  });\n}\n\nfunction getDefaultIdempotencyKey(method: string, maxRetries: number) {\n  if (method.toUpperCase() !== 'POST' || maxRetries === 0) return;\n  return `magicbell-retry-${uuid4()}`;\n}\n\nfunction setRequestHeaders(options: ClientOptions, request: Request) {\n  const idempotencyKey =\n    request.headers.get('idempotency-key') ||\n    options.idempotencyKey ||\n    getDefaultIdempotencyKey(request.method, options.maxRetries);\n\n  // default headers\n  request.headers.set('accept-version', 'v2');\n  request.headers.set('content-type', 'application/json');\n  request.headers.set('accept', 'application/json');\n  request.headers.set('idempotency-key', idempotencyKey);\n\n  // user provided headers\n  for (const [key, value] of Object.entries(options.headers || {})) {\n    request.headers.set(key, value);\n  }\n\n  // can't set user-agent in the browser, see https://developer.mozilla.org/en-US/docs/Glossary/Forbidden_header_name\n  request.headers.set('user-agent', typeof document !== 'undefined' ? '' : getUserAgent(options.appInfo));\n\n  // magicbell headers\n  request.headers.set('x-magicbell-api-key', options.apiKey);\n  request.headers.set('x-magicbell-api-secret', options.apiSecret);\n  request.headers.set('x-magicbell-client-user-agent', getClientUserAgent(options.appInfo));\n  request.headers.set('x-magicbell-user-email', options.userEmail);\n  request.headers.set('x-magicbell-user-external-id', options.userExternalId);\n  request.headers.set('x-magicbell-user-hmac', options.userHmac);\n\n  // remove empty headers, they can cause unexpected behavior\n  deleteEmptyHeaders(request.headers);\n}\n\nexport function withRequestHeaders(options: ClientOptions): Hooks {\n  return {\n    beforeRequest: [(request) => setRequestHeaders(options, request)],\n  };\n}\n\nfunction getEnvInfo() {\n  const common = {\n    binding: __PACKAGE_NAME__,\n    binding_version: __PACKAGE_VERSION__,\n    publisher: 'magicbell',\n  };\n\n  if (typeof process === 'undefined') {\n    return common;\n  }\n\n  return {\n    ...common,\n    runtime: process?.release?.name || 'node',\n    runtime_version: process.version,\n    platform: process.platform,\n    arch: process.arch,\n  };\n}\n\nfunction getAppInfoAsString(appInfo?: ClientOptions['appInfo']) {\n  if (!appInfo?.name) return '';\n\n  return [appInfo?.name, appInfo.version && `/${appInfo.version}`, appInfo.url && ` (${appInfo.url})`]\n    .filter(Boolean)\n    .join('');\n}\n\nfunction getUserAgent(appInfo?: ClientOptions['appInfo']) {\n  const env = getEnvInfo();\n\n  return [\n    `${env.binding}/${env.binding_version}`,\n    'runtime' in env && `${env.runtime}/${env.runtime_version}`,\n    getAppInfoAsString(appInfo),\n  ]\n    .filter(Boolean)\n    .join(' ');\n}\n\nfunction getClientUserAgent(appInfo?: ClientOptions['appInfo']) {\n  return JSON.stringify({ ...getEnvInfo(), application: appInfo });\n}\n","import Debug from 'debug';\nimport { toCurl } from 'fetch-addons';\nimport type { Hooks } from 'ky';\n\nexport const info = Debug('magicbell:info');\nexport const debug = Debug('magicbell:debug');\nexport const error = Debug('magicbell:error');\n\nfunction mask(str: string) {\n  if (__DEV__) return str;\n  // note, can't use real ellipsis, that'd throw\n  //  error: Cannot convert argument to a ByteString because the character at index 4 has a value of 8230 which is greater than 255.\n  return `${str.slice(0, 4)}...${str.slice(-4)}`;\n}\n\nconst secretHeaders = ['x-magicbell-api-secret'];\n// Exclude these headers, as they don't hold valuable info for debugging\n// and we don't want these values to be replayed when users copy/paste the curl\n// command. It would potentially mess up our telemetry.\nconst excludeHeaders = ['user-agent', 'x-magicbell-client-user-agent', 'x-magicbell-client-telemetry'];\n\nexport function withRequestLogging(): Hooks {\n  return {\n    beforeRequest: [(request) => debug(`${request.method} ${request.url}`)],\n    beforeError: [\n      async (err) => {\n        const req = err.request.clone();\n        excludeHeaders.forEach((header) => req.headers.delete(header));\n\n        req.headers.forEach((value, key) => {\n          if (secretHeaders.includes(key)) req.headers.set(key, mask(value));\n        });\n\n        const curl = await toCurl(req).then((x) => x.replace(/\\\\\\n/g, ' ').replace(/\\s+/g, ' '));\n        error(`${err.message}: ${curl}`);\n        return err;\n      },\n    ],\n  };\n}\n","import type { Hooks } from 'ky';\n\nimport { hasOwn, isBoolean, isNumber, isObject, isString, joinAnd, joinOr } from '../lib/utils';\nimport { ClientOptions } from './types';\n\nconst optionValidators: Record<keyof ClientOptions, (value: unknown) => boolean> = {\n  host: isString,\n  maxRetryDelay: isNumber,\n  timeout: isNumber,\n  apiKey: isString,\n  maxRetries: isNumber,\n  userEmail: isString,\n  userExternalId: isString,\n  userHmac: isString,\n  idempotencyKey: isString,\n  telemetry: isBoolean,\n  apiSecret: isString,\n  appInfo: isObject,\n  features: isObject,\n  headers: isObject,\n  hooks: isObject,\n};\n\nexport function isOptionsHash(object) {\n  if (!isObject(object)) return false;\n\n  for (const key of Object.keys(object)) {\n    if (!optionValidators[key]?.(object[key])) return false;\n  }\n\n  return true;\n}\n\nexport function assertHasValidOptions<T extends ClientOptions>(options: T) {\n  const invalidOptions = Object.keys(options).filter((x) => options[x] != null && !optionValidators[x]?.(options[x]));\n  if (invalidOptions.length) {\n    throw new Error(\n      `You have provided invalid client options. Please check the options ${joinAnd(...invalidOptions)}.`,\n    );\n  }\n}\n\nexport function assertHasRequiredOptions<T extends ClientOptions, K extends keyof ClientOptions>(\n  options: T,\n  required: K[],\n) {\n  const missingOptions = required.filter((x) => !hasOwn(options, x) || options[x] == null || options[x] === '');\n  if (missingOptions.length) {\n    throw new Error(`You have not provided all required client options. Please provide ${joinAnd(...missingOptions)}.`);\n  }\n}\n\nexport function assertHasSomeOptions<T extends ClientOptions, K extends keyof ClientOptions>(options: T, keys: K[]) {\n  const missingOptions = keys.filter((x) => !hasOwn(options, x) || options[x] == null || options[x] === '');\n  if (missingOptions.length === keys.length) {\n    throw new Error(`You have not provided any of the required client options. Please provide ${joinOr(...keys)}.`);\n  }\n}\n\nexport function mergeHooks(...hooks: Hooks[]): Hooks {\n  const result = {} as Hooks;\n\n  for (const hook of hooks) {\n    for (const key of Object.keys(hook || {})) {\n      result[key] ??= [];\n      result[key].push(...hook[key]);\n    }\n  }\n\n  return result;\n}\n","import type { Hooks, NormalizedOptions } from 'ky';\n\nimport { ClientOptions } from './types';\n\ntype Telemetry = { id: string; runtime: number; duration: number; status: number };\n\nconst history: Telemetry[] = [];\nlet enabled = true;\n\nfunction trackRequest(request: Request) {\n  (request as any).startTime = Date.now();\n  const record = history.pop();\n\n  // we still track response time locally, so we can print it in the console\n  if (!record || !enabled) return;\n  request.headers.set('x-magicbell-client-telemetry', JSON.stringify(record));\n}\n\nfunction captureResponse(request: Request, option: NormalizedOptions, response?: Response) {\n  if (!response?.status) return;\n\n  const { startTime } = request as any;\n  if (!startTime) return;\n\n  history.push({\n    id: response.headers.get('x-request-id'),\n    runtime: Number(response.headers.get('x-runtime')),\n    duration: Date.now() - startTime,\n    status: response.status,\n  });\n\n  // returning is a must, otherwise node keeps hanging on the unused response (clone)\n  // see: https://github.com/sindresorhus/ky-universal/issues/46#issuecomment-1620553766\n  return response;\n}\n\nexport function withRequestTelemetry(options: ClientOptions): Hooks {\n  enabled = options.telemetry !== false;\n\n  return {\n    beforeRequest: [trackRequest],\n    afterResponse: [captureResponse],\n  };\n}\n","import ky from 'ky';\n\nimport { tryParse } from '../lib/utils';\nimport { createError } from './error';\nimport { withRequestHeaders } from './headers';\nimport { withRequestLogging } from './log';\nimport { assertHasRequiredOptions, assertHasValidOptions, mergeHooks } from './options';\nimport { withRequestTelemetry } from './telemetry';\nimport { ClientOptions, FeatureFlag, RequestArgs, RequestOptions } from './types';\n\nexport const DEFAULT_OPTIONS: Partial<ClientOptions> = {\n  host: 'https://api.magicbell.com',\n  timeout: 30_000,\n  maxRetries: 3,\n  maxRetryDelay: 60,\n  telemetry: true,\n};\n\nexport class Client {\n  #options: ClientOptions;\n\n  constructor(options: ClientOptions) {\n    assertHasValidOptions(options);\n    assertHasRequiredOptions(options, ['apiKey']);\n    this.#options = { ...DEFAULT_OPTIONS, ...options };\n  }\n\n  hasFlag(flag: FeatureFlag) {\n    return this.#options.features?.[flag] || false;\n  }\n\n  async request<TResponse = any>(\n    { method, path, data, params, headers: reqHeaders }: RequestArgs,\n    options?: RequestOptions,\n  ) {\n    const requestOptions: ClientOptions & RequestOptions = {\n      ...this.#options,\n      ...options,\n      headers: { ...this.#options.headers, ...reqHeaders },\n    };\n\n    // don't just use `new URL(path, host)` as that will strip the path from the host\n    const url = new URL(requestOptions.host);\n    url.pathname = url.pathname.replace(/\\/$/, '') + path;\n\n    for (const [key, value] of Object.entries(params || {})) {\n      url.searchParams.append(key, Array.isArray(value) ? value.join(',') : value);\n    }\n\n    const hooks = mergeHooks(\n      withRequestHeaders(requestOptions),\n      withRequestTelemetry(requestOptions),\n      withRequestLogging(),\n      this.#options.hooks,\n    );\n\n    return ky(url, {\n      method,\n      body: data && JSON.stringify(data),\n      retry: {\n        limit: requestOptions.maxRetries,\n        // all methods, as post get idempotency keys\n        methods: ['get', 'post', 'put', 'head', 'delete', 'options', 'trace'],\n      },\n      timeout: requestOptions.timeout,\n      hooks,\n    })\n      .then((response) =>\n        response\n          .text()\n          // handle cases where the response is empty\n          .then((text) => JSON.parse(text) as TResponse)\n          .catch(() => undefined as TResponse),\n      )\n      .catch(async (error) => {\n        const body = tryParse(await error?.response?.text());\n\n        throw createError({\n          code: error.code,\n          name: error.name,\n          message: error.message,\n          type: error['type'],\n          status: error?.response?.status,\n          statusText: error?.response?.statusText,\n          responseBody: body,\n          ...body?.errors?.[0],\n        });\n      });\n  }\n}\n","import { hasOwn } from '../lib/utils';\n\nexport const ASYNC_ITERATOR_SYMBOL =\n  typeof Symbol !== 'undefined' && Symbol.asyncIterator ? Symbol.asyncIterator : '@@asyncIterator';\n\nfunction hasMore(pageResult, nodeCount: number) {\n  if (!hasOwn(pageResult, 'current_page') || !hasOwn(pageResult, 'per_page')) {\n    return false;\n  }\n\n  if (hasOwn(pageResult, 'total_pages')) {\n    return pageResult.current_page < pageResult.total_pages;\n  }\n\n  return nodeCount === pageResult.per_page;\n}\n\nexport function autoPaginate(makeRequest, { data, params }) {\n  const promiseCache = { currentPromise: null };\n  const reverseIteration = typeof params.after !== 'undefined';\n\n  let i = 0;\n  let request = makeRequest({ data, params });\n\n  const getNextPage = (pageResult) => {\n    const page = pageResult.current_page + 1;\n    return makeRequest({ data, params: { ...params, page } });\n  };\n\n  function iterate(pageResult) {\n    const dataKey = Object.keys(pageResult).find((key) => Array.isArray(pageResult[key]));\n    const data = pageResult[dataKey] || pageResult.data;\n\n    if (!data || typeof data.length !== 'number') {\n      throw Error('Unexpected: MagicBell API response does not have a well-formed response.');\n    }\n\n    if (i < data.length) {\n      const idx = reverseIteration ? data.length - 1 - i : i;\n      const value = data[idx];\n      i += 1;\n\n      return { value, done: false };\n    }\n\n    if (hasMore(pageResult, data.length)) {\n      // Reset counter, request next page, and recurse.\n      i = 0;\n      request = getNextPage(pageResult);\n      return request.then(iterate);\n    }\n\n    return { value: undefined, done: true };\n  }\n\n  function asyncIteratorNext() {\n    return memoizedPromise(promiseCache, (resolve, reject) => {\n      return request.then(iterate).then(resolve).catch(reject);\n    });\n  }\n\n  const forEach = makeForEach(asyncIteratorNext);\n  const toArray = makeToArray(forEach);\n\n  const autoPaginationMethods = {\n    forEach,\n    toArray,\n\n    next: asyncIteratorNext,\n    return: () => ({}),\n    [ASYNC_ITERATOR_SYMBOL]: () => {\n      return autoPaginationMethods;\n    },\n  };\n\n  return Object.assign(request, autoPaginationMethods);\n}\n\n/**\n * If a user calls `.next()` multiple times in parallel,\n * return the same result until something has resolved\n * to prevent page-turning race conditions.\n */\nfunction memoizedPromise(promiseCache, cb) {\n  if (promiseCache.currentPromise) {\n    return promiseCache.currentPromise;\n  }\n  promiseCache.currentPromise = new Promise(cb).then((ret) => {\n    promiseCache.currentPromise = undefined;\n    return ret;\n  });\n  return promiseCache.currentPromise;\n}\n\nexport function makeForEach(asyncIteratorNext, onDoneCallback?: () => void) {\n  return function forEach(onItem) {\n    return new Promise<void>((resolve, reject) => {\n      let idx = 0;\n      function handleIteration(iterResult) {\n        // iterResult can be undefined if the iterator is closed and quickly\n        // reconnected, this happens when wrapped in <React.StrictMode />.\n        // See github pr for more context: https://github.com/magicbell-io/magicbell-js/pull/189\n        if (iterResult?.done) {\n          resolve();\n          return;\n        }\n\n        const item = iterResult?.value;\n        return new Promise((resolve) => {\n          resolve(onItem(item, idx));\n        }).then((shouldContinue) => {\n          if (shouldContinue === false) {\n            onDoneCallback?.();\n            return handleIteration({ done: true });\n          } else {\n            idx++;\n            return asyncIteratorNext().then(handleIteration);\n          }\n        });\n      }\n\n      asyncIteratorNext().then(handleIteration).catch(reject);\n    });\n  };\n}\n\nfunction makeToArray(forEach) {\n  return function toArray(options) {\n    const limit = options?.limit;\n    if (!limit) {\n      throw Error('You must pass a `limit` option to toArray, e.g., `toArray({ limit: 1000 });`.');\n    }\n\n    if (limit > 10_000) {\n      throw Error(\n        'You cannot specify a limit of more than 10,000 items to fetch in `toArray`; use `forEach` to iterate through longer lists.',\n      );\n    }\n\n    return new Promise((resolve, reject) => {\n      const items = [];\n      forEach((item) => {\n        items.push(item);\n        if (items.length >= limit) {\n          return false;\n        }\n      })\n        .then(() => {\n          resolve(items);\n        })\n        .catch(reject);\n    });\n  };\n}\n","import ky from 'ky';\n\nimport { Client } from '../client/client';\nimport { ASYNC_ITERATOR_SYMBOL, makeForEach } from '../client/paginate';\nimport { RequestOptions } from '../client/types';\n\ntype AuthResponse = {\n  keyName: string;\n  timestamp: number;\n  nonce: string;\n  ttl: number;\n  mac: string;\n};\n\ntype TokenResponse = {\n  token: string;\n  keyName: string;\n  issued: number;\n  expires: number;\n  capability: string;\n  userClaims: string;\n};\n\ntype Event = {\n  id: string;\n  timestamp: number;\n  encoding: string;\n  channel: string;\n} & (\n  | { name: 'notifications/new'; data: { id: string } }\n  | { name: 'notifications/read'; data: { id: string; client_id: string } }\n  | { name: 'notifications/read/all'; data: { client_id: string } }\n  | { name: 'notifications/seen/all'; data: { client_id: string } }\n  | { name: 'notifications/unread'; data: { id: string; client_id: string } }\n  | { name: 'notifications/delete'; data: { id: string; client_id: string | null } }\n);\n\ntype IterableEventSource<TNode> = {\n  [Symbol.asyncIterator](): Iterator<TNode>;\n  forEach(cb: (node: TNode, index: number) => void | boolean | Promise<void | boolean>): Promise<void>;\n  close(): void;\n};\n\nexport type Listener = (options?: RequestOptions) => IterableEventSource<Event>;\n\nexport function createListener(client: InstanceType<typeof Client>, args: { sseHost?: string } = {}): Listener {\n  let eventSource: EventSource;\n  let channels: string;\n  let lastEvent: string;\n  let configPromise;\n\n  const messages: { value: Event; done: boolean }[] = [];\n  let resolve;\n  let activeCount = 0;\n\n  const pushMessage = (p) => {\n    messages.push(p);\n\n    if (resolve) {\n      resolve();\n      resolve = null;\n    }\n  };\n\n  // accept callback or yield\n  async function connect(options?: RequestOptions) {\n    activeCount++;\n\n    // invoke optional config request in the background, as we only need it after the ably authentication\n    if (!channels && !configPromise) {\n      configPromise = client\n        .request({ method: 'GET', path: '/config' }, options)\n        .then((x) => (channels = x.ws.channel));\n    }\n\n    const auth = await client.request<AuthResponse>({ method: 'POST', path: '/ws/auth' }, options);\n\n    // authenticate against ably\n    const { token } = await ky(`https://rest.ably.io/keys/${auth.keyName}/requestToken`, {\n      method: 'POST',\n      json: auth,\n    }).then((x) => x.json<TokenResponse>());\n\n    // make sure that the optional config request has finished\n    await configPromise;\n\n    // establish a connection with that token, the only reason we allow passing in the sseHost via args,\n    // is so that we have a way to reroute to localhost for testing.\n    const sseHost = args.sseHost || 'https://realtime.ably.io';\n    const url = new URL('sse', sseHost);\n\n    url.searchParams.append('v', '1.1');\n    url.searchParams.append('accessToken', token);\n    url.searchParams.append('channels', channels);\n    url.searchParams.append('heartbeats', 'true');\n\n    if (lastEvent) {\n      url.searchParams.append('lastEvent', lastEvent);\n    }\n\n    if (eventSource) {\n      eventSource.close();\n    }\n\n    // dispose could've been called while we were waiting for the config request to finish\n    if (activeCount < 1) return;\n\n    // new eventsource, flush all messages so we don't auto close this immediately\n    // because of stuck { done: true } messages in React.StrictMode\n    messages.length = 0;\n    eventSource = new EventSource(url.toString());\n\n    // handle incoming messages\n    eventSource.addEventListener('message', (event) => {\n      // event.origin can be undefined in react-native (devmode?)\n      if (event.origin && event.origin !== sseHost) return;\n\n      lastEvent = event.lastEventId;\n      if (!('data' in event)) return;\n\n      const message = JSON.parse(event.data);\n      if (message.type === 'close') {\n        return pushMessage({ value: null, done: true });\n      }\n\n      message.data = message.encoding === 'json' ? JSON.parse(message.data) : message.data;\n      pushMessage({ value: message, done: false });\n    });\n\n    // handle close\n    eventSource.addEventListener('close', () => {\n      return pushMessage({ value: null, done: true });\n    });\n\n    // handle connection errors\n    eventSource.addEventListener('error', (msg) => {\n      const err = 'data' in msg ? JSON.parse((msg as any).data) : {};\n      const isTokenErr = err.code >= 40140 && err.code < 40150;\n      if (isTokenErr) {\n        eventSource.close();\n        connect(options);\n      } else if (/invalid channel id/i.test(err.message)) {\n        eventSource.close();\n        pushMessage({ value: null, done: true });\n      } else {\n        // eslint-disable-next-line no-console\n        console.log('sse error:', msg);\n      }\n    });\n  }\n\n  function listen(options?: RequestOptions): IterableEventSource<Event> {\n    void connect(options);\n\n    const asyncIteratorNext = async () => {\n      let event: typeof messages[number] | null = null;\n\n      // It's weird that `event` can be undefined? We don't push empty messages\n      // This happens when running in <React.StrictMode />. I guess there are\n      // two instances resolving the promise above, the second resolve results\n      // in no content. See this github pr for more context:\n      // https://github.com/magicbell-io/magicbell-js/pull/189\n      while (!event) {\n        if (!messages.length) await new Promise((r) => (resolve = r));\n        event = messages.pop();\n      }\n\n      if (!event) return { done: false, value: '' };\n      if (event.done && eventSource) eventSource.close();\n      return event;\n    };\n\n    const dispose = () => {\n      activeCount--;\n      eventSource?.close();\n      // push to resolve async iterators, return for sync ones\n      pushMessage({ done: true, value: undefined });\n      return { done: true, value: undefined };\n    };\n\n    const forEach = makeForEach(asyncIteratorNext, dispose);\n    const autoPaginationMethods = {\n      forEach,\n      close: () => void dispose(),\n\n      next: asyncIteratorNext,\n      return: dispose,\n      [ASYNC_ITERATOR_SYMBOL]: () => {\n        return autoPaginationMethods;\n      },\n    };\n\n    return autoPaginationMethods;\n  }\n\n  return listen;\n}\n","import { isArray, isBoolean, isObject, isString, isStringArray } from '../lib/utils';\nimport { isOptionsHash } from './options';\nimport { ClientOptions, RequestMethod } from './types';\n\ntype KeyOfType<T, V> = keyof {\n  [P in keyof T as T[P] extends V ? P : never]: any;\n};\n\nexport type IterablePromise<\n  TData,\n  TKey extends KeyOfType<TData, Array<unknown>> = KeyOfType<TData, Array<unknown>>,\n  TNode = TData[TKey] extends Array<unknown> ? TData[TKey][number] : never,\n> = Promise<TData> & {\n  [Symbol.asyncIterator](): Iterator<TNode>;\n  forEach(cb: (node: TNode, index: number) => void | boolean | Promise<void | boolean>): Promise<void>;\n  toArray(options: { limit: number }): Promise<Array<TNode>>;\n};\n\nconst queryParamValidators = {\n  archived: isBoolean,\n  read: isBoolean,\n  seen: isBoolean,\n  categories: (value) => isString(value) || isStringArray(value),\n  topics: (value) => isString(value) || isStringArray(value),\n};\n\nfunction isForcedQueryParams(object) {\n  if (!isObject(object)) return false;\n\n  for (const key of Object.keys(object)) {\n    if (!queryParamValidators[key]?.(object[key])) return false;\n  }\n\n  return true;\n}\n\nfunction getUrl(path: string, params: Record<string, string>, options = { encode: true }) {\n  return path.replace(/{([\\s\\S]+?)}/g, ($0, $1) =>\n    options.encode ? encodeURIComponent(params[$1] || '') : params[$1] || '',\n  );\n}\n\nfunction extractUrlParams(path: string) {\n  const params = path.match(/{\\w+}/g) || [];\n  return (params || []).map((param) => param.replace(/[{}]/g, ''));\n}\n\n/**\n * Return the data argument from a list of arguments\n *\n * @param {object[]} args\n * @returns {object}\n */\nfunction getDataFromArgs(args): Record<string, unknown> {\n  if (!isArray(args) || !isObject(args[0])) return {};\n  if (isOptionsHash(args[0])) return {};\n  return args.shift();\n}\n\n/**\n * Return the options hash from a list of arguments\n */\nfunction getOptionsFromArgs(args): Partial<ClientOptions> {\n  if (!isArray(args) || args.length === 0) return {};\n\n  const arg = args[args.length - 1];\n  if (!isOptionsHash(arg)) return {};\n\n  return { ...args.pop() };\n}\n\nexport function normalizeArgs({\n  path,\n  method,\n  args,\n}: {\n  path: string;\n  method: RequestMethod;\n  args: (Record<string, unknown> | string)[];\n}) {\n  const argsCopy = [...args].filter((x) => x !== undefined);\n\n  const urlParams = extractUrlParams(path);\n  const urlData = urlParams.reduce((urlData, param) => {\n    const arg = argsCopy.shift();\n    if (typeof arg !== 'string') {\n      throw new Error(\n        `MagicBell: Argument \"${param}\" must be a string, but got ${typeof arg}: ${JSON.stringify(\n          arg,\n        )} (on API request to \\`${method} ${path}\\`)`,\n      );\n    }\n\n    urlData[param] = arg;\n    return urlData;\n  }, {});\n\n  // We don't encode atm because the backend doesn't support that in PUT /users/email:user@domain.com\n  const url = getUrl(path, urlData, { encode: false });\n  const dataFromArgs = getDataFromArgs(argsCopy);\n  const options = getOptionsFromArgs(argsCopy);\n\n  // Validate that there are no more args.\n  if (argsCopy.filter((x) => x != null).length) {\n    throw new Error(\n      `MagicBell: Unknown arguments (${JSON.stringify(argsCopy)}). (on API request to \\`${method} ${url}\\`)`,\n    );\n  }\n\n  // Note, DELETE requests should have data in the params, but our `subscriptions.delete`\n  //   endpoint reads it from the body. Other delete requests don't have data, so this seems\n  //   to be the best solution for now.\n  let dataInQuery = method === 'GET'; // || method === 'DELETE';\n\n  // We have a few POST methods using query data instead of body data.\n  if (method === 'POST' && isForcedQueryParams(dataFromArgs)) {\n    dataInQuery = true;\n  }\n\n  const data = dataInQuery ? {} : dataFromArgs;\n  const params = dataInQuery ? dataFromArgs : {};\n\n  return { path: url, data, params, options };\n}\n","import { joinUrlSegments } from '../lib/utils';\nimport { Client } from './client';\nimport { IterablePromise, normalizeArgs } from './method';\nimport { autoPaginate } from './paginate';\nimport { FeatureFlag } from './types';\n\ntype ResourceRequestOptions = {\n  method: 'GET' | 'PUT' | 'POST' | 'DELETE' | 'PATCH';\n  path?: string;\n  paged?: boolean;\n};\n\nfunction isEmptyPayload(data: unknown): boolean {\n  if (!data) return true;\n  if (Array.isArray(data)) return data.length === 0;\n  if (typeof data === 'object') return Object.keys(data).length === 0;\n  return false;\n}\n\nexport class Resource {\n  path: string;\n  entity: string;\n\n  protected client: InstanceType<typeof Client>;\n\n  constructor(client: InstanceType<typeof Client>) {\n    this.client = client;\n  }\n\n  protected request<TData = any>(\n    options: ResourceRequestOptions & { paged: true },\n    ...args: (string | Record<string, unknown>)[]\n  ): IterablePromise<TData>;\n\n  protected request<TData = any>(\n    options: ResourceRequestOptions & { paged?: false | never },\n    ...args: (string | Record<string, unknown>)[]\n  ): Promise<TData>;\n\n  protected request(\n    { method, paged, path: tplPath }: ResourceRequestOptions,\n    ...args: (string | Record<string, unknown>)[]\n  ) {\n    const { path, data, params, options } = normalizeArgs({\n      path: joinUrlSegments(this.path, tplPath),\n      method,\n      args,\n    });\n\n    const makeRequest = ({ data, params }) => {\n      const entity = this.entity || this.path;\n      data = isEmptyPayload(data) ? undefined : { [entity]: data };\n      params = isEmptyPayload(params) ? undefined : params;\n\n      return this.client\n        .request({ method, path, data, params }, options)\n        .then((response) => response?.[entity] || response);\n    };\n\n    if (paged) {\n      return autoPaginate(makeRequest, {\n        data,\n        params,\n      });\n    }\n\n    return makeRequest({ data, params });\n  }\n\n  protected assertFeatureFlag(flag: FeatureFlag) {\n    if (!this.client.hasFlag(flag)) {\n      throw new Error(`This is a beta feature, please enable it by providing the \"${flag}\" feature flag.`);\n    }\n  }\n}\n","// This file is generated. Do not update manually!\n\nimport { type FromSchema } from 'json-schema-to-ts';\n\nimport { Resource } from '../client/resource';\nimport { type RequestOptions } from '../client/types';\nimport * as schemas from '../schemas/notification-preferences';\n\ntype GetNotificationPreferencesResponse = FromSchema<typeof schemas.GetNotificationPreferencesResponseSchema>;\ntype UpdateNotificationPreferencesResponse = FromSchema<typeof schemas.UpdateNotificationPreferencesResponseSchema>;\ntype UpdateNotificationPreferencesPayload = FromSchema<typeof schemas.UpdateNotificationPreferencesPayloadSchema>;\n\nexport class NotificationPreferences extends Resource {\n  path = 'notification_preferences';\n  entity = 'notification_preferences';\n\n  /**\n   * Fetch a user's notification preferences. If a user does not disable a channel\n   * explicitly, we would send notifications through that channel as long as your\n   * project is enabled.\n   *\n   * @param options - override client request options.\n   * @returns\n   **/\n  get(options?: RequestOptions): Promise<GetNotificationPreferencesResponse> {\n    return this.request(\n      {\n        method: 'GET',\n      },\n      options,\n    );\n  }\n\n  /**\n   * Update a user's notification preferences. These preferences will be applied only\n   * to channels you enabled for your project.\n   *\n   * @param options - override client request options.\n   * @returns\n   **/\n  update(options?: RequestOptions): Promise<UpdateNotificationPreferencesResponse>;\n\n  /**\n   * Update a user's notification preferences. These preferences will be applied only\n   * to channels you enabled for your project.\n   *\n   * @param data\n   * @param options - override client request options.\n   * @returns\n   **/\n  update(\n    data: UpdateNotificationPreferencesPayload,\n    options?: RequestOptions,\n  ): Promise<UpdateNotificationPreferencesResponse>;\n\n  update(\n    dataOrOptions: UpdateNotificationPreferencesPayload | RequestOptions,\n    options?: RequestOptions,\n  ): Promise<UpdateNotificationPreferencesResponse> {\n    return this.request(\n      {\n        method: 'PUT',\n      },\n      dataOrOptions,\n      options,\n    );\n  }\n}\n","// This file is generated. Do not update manually!\n\nimport { type FromSchema } from 'json-schema-to-ts';\n\nimport { type IterablePromise } from '../client/method';\nimport { Resource } from '../client/resource';\nimport { type RequestOptions } from '../client/types';\nimport * as schemas from '../schemas/notifications';\n\ntype MarkAllReadNotificationsPayload = FromSchema<typeof schemas.MarkAllReadNotificationsPayloadSchema>;\ntype MarkAllSeenNotificationsPayload = FromSchema<typeof schemas.MarkAllSeenNotificationsPayloadSchema>;\ntype ListNotificationsResponse = FromSchema<typeof schemas.ListNotificationsResponseSchema>;\ntype ListNotificationsPayload = FromSchema<typeof schemas.ListNotificationsPayloadSchema>;\ntype GetNotificationsResponse = FromSchema<typeof schemas.GetNotificationsResponseSchema>;\n\nexport class Notifications extends Resource {\n  path = 'notifications';\n  entity = 'notification';\n\n  /**\n   * Mark a user notification as archived.\n   *\n   * @param notificationId - ID of the user notification.\n   *   The ID of a user notification can be obtained from the \"Fetch user\n   *   notifications\" API endpoint or from push events sent to the MagicBell React\n   *   library.\n   *\n   * @param options - override client request options.\n   **/\n  archive(notificationId: string, options?: RequestOptions): Promise<void> {\n    return this.request(\n      {\n        method: 'POST',\n        path: '{notification_id}/archive',\n      },\n      notificationId,\n      options,\n    );\n  }\n\n  /**\n   * Mark all notifications of a user as read. When you call this endpoint, the\n   * notification inboxes of this user will be updated in real-time.\n   *\n   * @param options - override client request options.\n   **/\n  markAllRead(options?: RequestOptions): Promise<void>;\n\n  /**\n   * Mark all notifications of a user as read. When you call this endpoint, the\n   * notification inboxes of this user will be updated in real-time.\n   *\n   * @param data\n   * @param options - override client request options.\n   **/\n  markAllRead(data: MarkAllReadNotificationsPayload, options?: RequestOptions): Promise<void>;\n\n  markAllRead(\n    dataOrOptions: MarkAllReadNotificationsPayload | RequestOptions,\n    options?: RequestOptions,\n  ): Promise<void> {\n    return this.request(\n      {\n        method: 'POST',\n        path: 'read',\n      },\n      dataOrOptions,\n      options,\n    );\n  }\n\n  /**\n   * Mark all notifications of a user as seen. When you call this endpoint, the\n   * notification inboxes of this user will be updated in real-time.\n   *\n   * @param options - override client request options.\n   **/\n  markAllSeen(options?: RequestOptions): Promise<void>;\n\n  /**\n   * Mark all notifications of a user as seen. When you call this endpoint, the\n   * notification inboxes of this user will be updated in real-time.\n   *\n   * @param data\n   * @param options - override client request options.\n   **/\n  markAllSeen(data: MarkAllSeenNotificationsPayload, options?: RequestOptions): Promise<void>;\n\n  markAllSeen(\n    dataOrOptions: MarkAllSeenNotificationsPayload | RequestOptions,\n    options?: RequestOptions,\n  ): Promise<void> {\n    return this.request(\n      {\n        method: 'POST',\n        path: 'seen',\n      },\n      dataOrOptions,\n      options,\n    );\n  }\n\n  /**\n   * Mark a user notification as read. The notification will be automatically marked\n   * as seen, too.\n   *\n   * The new state will be reflected in the user's notification inbox in real-time.\n   *\n   * @param notificationId - ID of the user notification.\n   *   The ID of a user notification can be obtained from the \"Fetch user\n   *   notifications\" API endpoint or from push events sent to the MagicBell React\n   *   library.\n   *\n   * @param options - override client request options.\n   **/\n  markAsRead(notificationId: string, options?: RequestOptions): Promise<void> {\n    return this.request(\n      {\n        method: 'POST',\n        path: '{notification_id}/read',\n      },\n      notificationId,\n      options,\n    );\n  }\n\n  /**\n   * Mark a user notification as unread. The new state will be reflected in the\n   * user's notification inbox in real-time.\n   *\n   * @param notificationId - ID of the user notification.\n   *   The ID of a user notification can be obtained from the \"Fetch user\n   *   notifications\" API endpoint or from push events sent to the MagicBell React\n   *   library.\n   *\n   * @param options - override client request options.\n   **/\n  markAsUnread(notificationId: string, options?: RequestOptions): Promise<void> {\n    return this.request(\n      {\n        method: 'POST',\n        path: '{notification_id}/unread',\n      },\n      notificationId,\n      options,\n    );\n  }\n\n  /**\n   * Fetch a user's notifications. Notifications are sorted in descending order by\n   * the sent_at timestamp.\n   *\n   * @param options - override client request options.\n   * @returns\n   **/\n  list(options?: RequestOptions): IterablePromise<ListNotificationsResponse>;\n\n  /**\n   * Fetch a user's notifications. Notifications are sorted in descending order by\n   * the sent_at timestamp.\n   *\n   * @param data\n   * @param options - override client request options.\n   * @returns\n   **/\n  list(data: ListNotificationsPayload, options?: RequestOptions): IterablePromise<ListNotificationsResponse>;\n\n  list(\n    dataOrOptions: ListNotificationsPayload | RequestOptions,\n    options?: RequestOptions,\n  ): IterablePromise<ListNotificationsResponse> {\n    return this.request(\n      {\n        method: 'GET',\n        paged: true,\n      },\n      dataOrOptions,\n      options,\n    );\n  }\n\n  /**\n   * Fetch a user's notification by its ID.\n   *\n   * @param notificationId - ID of the user notification.\n   *   The ID of a user notification can be obtained from the \"Fetch user\n   *   notifications\" API endpoint or from push events sent to the MagicBell React\n   *   library.\n   *\n   * @param options - override client request options.\n   * @returns\n   **/\n  get(notificationId: string, options?: RequestOptions): Promise<GetNotificationsResponse> {\n    return this.request(\n      {\n        method: 'GET',\n        path: '{notification_id}',\n      },\n      notificationId,\n      options,\n    );\n  }\n\n  /**\n   * Delete a user's notification by its ID. The notification is deleted immediately\n   * and removed from the user's notification inbox in real-time.\n   *\n   * @param notificationId - ID of the user notification.\n   *   The ID of a user notification can be obtained from the \"Fetch user\n   *   notifications\" API endpoint or from push events sent to the MagicBell React\n   *   library.\n   *\n   * @param options - override client request options.\n   **/\n  delete(notificationId: string, options?: RequestOptions): Promise<void> {\n    return this.request(\n      {\n        method: 'DELETE',\n        path: '{notification_id}',\n      },\n      notificationId,\n      options,\n    );\n  }\n\n  /**\n   * Mark a user notification as unarchived.\n   *\n   * @param notificationId - ID of the user notification.\n   *   The ID of a user notification can be obtained from the \"Fetch user\n   *   notifications\" API endpoint or from push events sent to the MagicBell React\n   *   library.\n   *\n   * @param options - override client request options.\n   **/\n  unarchive(notificationId: string, options?: RequestOptions): Promise<void> {\n    return this.request(\n      {\n        method: 'DELETE',\n        path: '{notification_id}/archive',\n      },\n      notificationId,\n      options,\n    );\n  }\n}\n","// This file is generated. Do not update manually!\n\nimport { type FromSchema } from 'json-schema-to-ts';\n\nimport { type IterablePromise } from '../client/method';\nimport { Resource } from '../client/resource';\nimport { type RequestOptions } from '../client/types';\nimport * as schemas from '../schemas/push-subscriptions';\n\ntype CreatePushSubscriptionsResponse = FromSchema<typeof schemas.CreatePushSubscriptionsResponseSchema>;\ntype CreatePushSubscriptionsPayload = FromSchema<typeof schemas.CreatePushSubscriptionsPayloadSchema>;\ntype ListPushSubscriptionsResponse = FromSchema<typeof schemas.ListPushSubscriptionsResponseSchema>;\n\nexport class PushSubscriptions extends Resource {\n  path = 'push_subscriptions';\n  entity = 'push_subscription';\n\n  /**\n   * Register a device token for push notifications.\n   *\n   * Please keep in mind that mobile push notifications will be delivered to this\n   * device only if the channel is configured and enabled.\n   *\n   * @param data\n   * @param options - override client request options.\n   * @returns\n   **/\n  create(data: CreatePushSubscriptionsPayload, options?: RequestOptions): Promise<CreatePushSubscriptionsResponse> {\n    return this.request(\n      {\n        method: 'POST',\n      },\n      data,\n      options,\n    );\n  }\n\n  /**\n   * Returns the list of device tokens registered for push notifications.\n   *\n   * @param options - override client request options.\n   * @returns\n   **/\n  list(options?: RequestOptions): IterablePromise<ListPushSubscriptionsResponse> {\n    return this.request(\n      {\n        method: 'GET',\n        paged: true,\n      },\n      options,\n    );\n  }\n\n  /**\n   * Deletes the registered device token to remove the mobile push subscription.\n   *\n   * @param deviceToken - Token of the device you want to remove\n   * @param options - override client request options.\n   **/\n  delete(deviceToken: string, options?: RequestOptions): Promise<void> {\n    return this.request(\n      {\n        method: 'DELETE',\n        path: '{device_token}',\n      },\n      deviceToken,\n      options,\n    );\n  }\n}\n","// This file is generated. Do not update manually!\n\nimport { type FromSchema } from 'json-schema-to-ts';\n\nimport { type IterablePromise } from '../client/method';\nimport { Resource } from '../client/resource';\nimport { type RequestOptions } from '../client/types';\nimport * as schemas from '../schemas/subscriptions';\n\ntype CreateSubscriptionsResponse = FromSchema<typeof schemas.CreateSubscriptionsResponseSchema>;\ntype CreateSubscriptionsPayload = FromSchema<typeof schemas.CreateSubscriptionsPayloadSchema>;\ntype UnsubscribeSubscriptionsResponse = FromSchema<typeof schemas.UnsubscribeSubscriptionsResponseSchema>;\ntype UnsubscribeSubscriptionsPayload = FromSchema<typeof schemas.UnsubscribeSubscriptionsPayloadSchema>;\ntype ListSubscriptionsResponse = FromSchema<typeof schemas.ListSubscriptionsResponseSchema>;\ntype GetSubscriptionsResponse = FromSchema<typeof schemas.GetSubscriptionsResponseSchema>;\ntype DeleteSubscriptionsPayload = FromSchema<typeof schemas.DeleteSubscriptionsPayloadSchema>;\n\nexport class Subscriptions extends Resource {\n  path = 'subscriptions';\n  entity = 'subscription';\n\n  /**\n   * Set a user's subscription status to subscribed for a particular topic (and\n   * optional categories). If the user previously unsubscribed, the user will be\n   * resubscribed.\n   *\n   * @param data\n   * @param options - override client request options.\n   * @returns\n   **/\n  create(data: CreateSubscriptionsPayload, options?: RequestOptions): Promise<CreateSubscriptionsResponse> {\n    return this.request(\n      {\n        method: 'POST',\n      },\n      data,\n      options,\n    );\n  }\n\n  /**\n   * Unusbscribe a user from a particular topic (and optional categories).\n   *\n   * @param topic - The topic for which we'd like to filter topic subscriptions.\n   * @param data\n   * @param options - override client request options.\n   * @returns\n   **/\n  unsubscribe(\n    topic: string,\n    data: UnsubscribeSubscriptionsPayload,\n    options?: RequestOptions,\n  ): Promise<UnsubscribeSubscriptionsResponse> {\n    return this.request(\n      {\n        method: 'POST',\n        path: '{topic}/unsubscribe',\n      },\n      topic,\n      data,\n      options,\n    );\n  }\n\n  /**\n   * Fetch a user's topic subscriptions.\n   *\n   * @param options - override client request options.\n   * @returns\n   **/\n  list(options?: RequestOptions): IterablePromise<ListSubscriptionsResponse> {\n    return this.request(\n      {\n        method: 'GET',\n        paged: true,\n      },\n      options,\n    );\n  }\n\n  /**\n   * Show a user's subscription status for a particular topic and categories.\n   *\n   * @param topic - The topic for which we'd like to filter topic subscriptions.\n   * @param options - override client request options.\n   * @returns\n   **/\n  get(topic: string, options?: RequestOptions): Promise<GetSubscriptionsResponse> {\n    return this.request(\n      {\n        method: 'GET',\n        path: '{topic}',\n      },\n      topic,\n      options,\n    );\n  }\n\n  /**\n   * Delete topic subscription(s)\n   *\n   * @param topic - The topic for which we'd like to filter topic subscriptions.\n   * @param options - override client request options.\n   **/\n  delete(topic: string, options?: RequestOptions): Promise<void>;\n\n  /**\n   * Delete topic subscription(s)\n   *\n   * @param topic - The topic for which we'd like to filter topic subscriptions.\n   * @param data\n   * @param options - override client request options.\n   **/\n  delete(topic: string, data: DeleteSubscriptionsPayload, options?: RequestOptions): Promise<void>;\n\n  delete(\n    topic: string,\n    dataOrOptions: DeleteSubscriptionsPayload | RequestOptions,\n    options?: RequestOptions,\n  ): Promise<void> {\n    return this.request(\n      {\n        method: 'DELETE',\n        path: '{topic}',\n      },\n      topic,\n      dataOrOptions,\n      options,\n    );\n  }\n}\n","import { Client } from './client/client';\nimport { assertHasRequiredOptions } from './client/options';\nimport { ClientOptions, WithRequired } from './client/types';\nimport { createListener } from './resources/listen';\nimport { NotificationPreferences } from './user-resources/notification-preferences';\nimport { Notifications } from './user-resources/notifications';\nimport { PushSubscriptions } from './user-resources/push-subscriptions';\nimport { Subscriptions } from './user-resources/subscriptions';\n\nexport type UserClientOptions =\n  | WithRequired<Omit<ClientOptions, 'apiSecret'>, 'apiKey' | 'userEmail'>\n  | WithRequired<Omit<ClientOptions, 'apiSecret'>, 'apiKey' | 'userExternalId'>;\n\nexport class UserClient extends Client {\n  listen = createListener(this);\n\n  notificationPreferences = new NotificationPreferences(this);\n  notifications = new Notifications(this);\n  pushSubscriptions = new PushSubscriptions(this);\n  subscriptions = new Subscriptions(this);\n\n  constructor(options: UserClientOptions) {\n    assertHasRequiredOptions(options, ['apiKey']);\n    if ('apiSecret' in options) {\n      throw new Error('The API secret should NOT be used on the user client.');\n    }\n\n    super(options);\n  }\n}\n"],"names":["error","data","resolve","urlData","params"],"mappings":"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"}