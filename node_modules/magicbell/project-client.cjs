/** 
 * @license magicbell v3.1.1
 *
 * Copyright (c) MagicBell Inc. and its affiliates.
 *
 * This source code is licensed under the license found in the
 * LICENSE file in the root directory of this source tree.
 */

"use strict";
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var __accessCheck = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet = (obj, member, getter) => {
  __accessCheck(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateSet = (obj, member, value, setter) => {
  __accessCheck(obj, member, "write to private field");
  setter ? setter.call(obj, value) : member.set(obj, value);
  return value;
};
var _options;
Object.defineProperties(exports, { __esModule: { value: true }, [Symbol.toStringTag]: { value: "Module" } });
const ky = require("ky");
const fetchAddons = require("fetch-addons");
const Debug = require("debug");
const _interopDefaultLegacy = (e) => e && typeof e === "object" && "default" in e ? e : { default: e };
const ky__default = /* @__PURE__ */ _interopDefaultLegacy(ky);
const Debug__default = /* @__PURE__ */ _interopDefaultLegacy(Debug);
const hasOwn = (obj, prop) => obj && Object.prototype.hasOwnProperty.call(obj, prop);
function isString(value) {
  return typeof value === "string";
}
function isBoolean(value) {
  return typeof value === "boolean";
}
function isArray(value) {
  return Array.isArray(value);
}
function isStringArray(value) {
  return Array.isArray(value) && value.every((x) => typeof x === "string");
}
function isNumber(value) {
  return typeof value === "number";
}
function isObject(value) {
  return value && typeof value === "object";
}
function joinAnd(...parts) {
  if (parts.length <= 2)
    return parts.join(" and ");
  const last = parts.slice(-1)[0];
  const others = parts.slice(0, -1);
  return [others.join(", "), last].join(", and ");
}
function joinUrlSegments(...segments) {
  return ["/", ...segments].join("/").replace(/\/+/g, "/").replace(/\/$/, "");
}
function tryParse(obj) {
  try {
    return JSON.parse(String(obj));
  } catch (e) {
    return obj;
  }
}
function createError(rawError) {
  for (const field of ["code", "type", "status"]) {
    switch (rawError[field]) {
      case "user_identifier_not_provided":
        return new AuthenticationError(rawError);
      case "invalid_request_error":
        return new InvalidRequestError(rawError);
      case "api_error":
        return new APIError(rawError);
      case "authentication_error":
        return new AuthenticationError(rawError);
      case "rate_limit_error":
        return new RateLimitError(rawError);
      case "idempotency_error":
        return new IdempotencyError(rawError);
      case 404:
        return new NotFoundError(rawError);
      case 422:
        return new UserInputError(rawError);
    }
  }
  return new UnknownError(rawError);
}
class MagicBellError extends Error {
  constructor(raw) {
    super(raw.message);
    __publicField(this, "name");
    __publicField(this, "message");
    __publicField(this, "type");
    __publicField(this, "docsUrl");
    __publicField(this, "code");
    __publicField(this, "status");
    __publicField(this, "statusText");
    __publicField(this, "suggestion");
    __publicField(this, "responseBody");
    this.type = this.constructor.name;
    this.name = "MagicBellError";
    this.code = raw.code;
    this.status = raw.status;
    this.statusText = raw.statusText;
    this.responseBody = raw.responseBody;
    this.message = raw.message;
    this.suggestion = raw.suggestion;
    this.docsUrl = raw.docs_url || raw.help_link;
  }
  get docs_url() {
    return this.docsUrl;
  }
}
class InvalidRequestError extends MagicBellError {
}
class UserInputError extends MagicBellError {
}
class APIError extends MagicBellError {
}
class AuthenticationError extends MagicBellError {
}
class RateLimitError extends MagicBellError {
}
class IdempotencyError extends MagicBellError {
}
class UnknownError extends MagicBellError {
}
class NotFoundError extends MagicBellError {
}
function uuid4() {
  return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (c) => {
    const r = Math.random() * 16 | 0;
    const v = c === "x" ? r : r & 3 | 8;
    return v.toString(16);
  });
}
function getDefaultIdempotencyKey(method, maxRetries) {
  if (method.toUpperCase() !== "POST" || maxRetries === 0)
    return;
  return `magicbell-retry-${uuid4()}`;
}
function setRequestHeaders(options, request) {
  const idempotencyKey = request.headers.get("idempotency-key") || options.idempotencyKey || getDefaultIdempotencyKey(request.method, options.maxRetries);
  request.headers.set("accept-version", "v2");
  request.headers.set("content-type", "application/json");
  request.headers.set("accept", "application/json");
  request.headers.set("idempotency-key", idempotencyKey);
  for (const [key, value] of Object.entries(options.headers || {})) {
    request.headers.set(key, value);
  }
  request.headers.set("user-agent", typeof document !== "undefined" ? "" : getUserAgent(options.appInfo));
  request.headers.set("x-magicbell-api-key", options.apiKey);
  request.headers.set("x-magicbell-api-secret", options.apiSecret);
  request.headers.set("x-magicbell-client-user-agent", getClientUserAgent(options.appInfo));
  request.headers.set("x-magicbell-user-email", options.userEmail);
  request.headers.set("x-magicbell-user-external-id", options.userExternalId);
  request.headers.set("x-magicbell-user-hmac", options.userHmac);
  fetchAddons.deleteEmptyHeaders(request.headers);
}
function withRequestHeaders(options) {
  return {
    beforeRequest: [(request) => setRequestHeaders(options, request)]
  };
}
function getEnvInfo() {
  var _a;
  const common = {
    binding: "magicbell",
    binding_version: "3.1.1",
    publisher: "magicbell"
  };
  if (typeof process === "undefined") {
    return common;
  }
  return __spreadProps(__spreadValues({}, common), {
    runtime: ((_a = process == null ? void 0 : process.release) == null ? void 0 : _a.name) || "node",
    runtime_version: process.version,
    platform: process.platform,
    arch: process.arch
  });
}
function getAppInfoAsString(appInfo) {
  if (!(appInfo == null ? void 0 : appInfo.name))
    return "";
  return [appInfo == null ? void 0 : appInfo.name, appInfo.version && `/${appInfo.version}`, appInfo.url && ` (${appInfo.url})`].filter(Boolean).join("");
}
function getUserAgent(appInfo) {
  const env = getEnvInfo();
  return [
    `${env.binding}/${env.binding_version}`,
    "runtime" in env && `${env.runtime}/${env.runtime_version}`,
    getAppInfoAsString(appInfo)
  ].filter(Boolean).join(" ");
}
function getClientUserAgent(appInfo) {
  return JSON.stringify(__spreadProps(__spreadValues({}, getEnvInfo()), { application: appInfo }));
}
Debug__default.default("magicbell:info");
const debug = Debug__default.default("magicbell:debug");
const error = Debug__default.default("magicbell:error");
function mask(str) {
  return str;
}
const secretHeaders = ["x-magicbell-api-secret"];
const excludeHeaders = ["user-agent", "x-magicbell-client-user-agent", "x-magicbell-client-telemetry"];
function withRequestLogging() {
  return {
    beforeRequest: [(request) => debug(`${request.method} ${request.url}`)],
    beforeError: [
      async (err) => {
        const req = err.request.clone();
        excludeHeaders.forEach((header) => req.headers.delete(header));
        req.headers.forEach((value, key) => {
          if (secretHeaders.includes(key))
            req.headers.set(key, mask(value));
        });
        const curl = await fetchAddons.toCurl(req).then((x) => x.replace(/\\\n/g, " ").replace(/\s+/g, " "));
        error(`${err.message}: ${curl}`);
        return err;
      }
    ]
  };
}
const optionValidators = {
  host: isString,
  maxRetryDelay: isNumber,
  timeout: isNumber,
  apiKey: isString,
  maxRetries: isNumber,
  userEmail: isString,
  userExternalId: isString,
  userHmac: isString,
  idempotencyKey: isString,
  telemetry: isBoolean,
  apiSecret: isString,
  appInfo: isObject,
  features: isObject,
  headers: isObject,
  hooks: isObject
};
function isOptionsHash(object) {
  var _a;
  if (!isObject(object))
    return false;
  for (const key of Object.keys(object)) {
    if (!((_a = optionValidators[key]) == null ? void 0 : _a.call(optionValidators, object[key])))
      return false;
  }
  return true;
}
function assertHasValidOptions(options) {
  const invalidOptions = Object.keys(options).filter((x) => {
    var _a;
    return options[x] != null && !((_a = optionValidators[x]) == null ? void 0 : _a.call(optionValidators, options[x]));
  });
  if (invalidOptions.length) {
    throw new Error(
      `You have provided invalid client options. Please check the options ${joinAnd(...invalidOptions)}.`
    );
  }
}
function assertHasRequiredOptions(options, required) {
  const missingOptions = required.filter((x) => !hasOwn(options, x) || options[x] == null || options[x] === "");
  if (missingOptions.length) {
    throw new Error(`You have not provided all required client options. Please provide ${joinAnd(...missingOptions)}.`);
  }
}
function mergeHooks(...hooks) {
  var _a;
  const result = {};
  for (const hook of hooks) {
    for (const key of Object.keys(hook || {})) {
      (_a = result[key]) != null ? _a : result[key] = [];
      result[key].push(...hook[key]);
    }
  }
  return result;
}
const history = [];
let enabled = true;
function trackRequest(request) {
  request.startTime = Date.now();
  const record = history.pop();
  if (!record || !enabled)
    return;
  request.headers.set("x-magicbell-client-telemetry", JSON.stringify(record));
}
function captureResponse(request, option, response) {
  if (!(response == null ? void 0 : response.status))
    return;
  const { startTime } = request;
  if (!startTime)
    return;
  history.push({
    id: response.headers.get("x-request-id"),
    runtime: Number(response.headers.get("x-runtime")),
    duration: Date.now() - startTime,
    status: response.status
  });
  return response;
}
function withRequestTelemetry(options) {
  enabled = options.telemetry !== false;
  return {
    beforeRequest: [trackRequest],
    afterResponse: [captureResponse]
  };
}
const DEFAULT_OPTIONS = {
  host: "https://api.magicbell.com",
  timeout: 3e4,
  maxRetries: 3,
  maxRetryDelay: 60,
  telemetry: true
};
class Client {
  constructor(options) {
    __privateAdd(this, _options, void 0);
    assertHasValidOptions(options);
    assertHasRequiredOptions(options, ["apiKey"]);
    __privateSet(this, _options, __spreadValues(__spreadValues({}, DEFAULT_OPTIONS), options));
  }
  hasFlag(flag) {
    var _a;
    return ((_a = __privateGet(this, _options).features) == null ? void 0 : _a[flag]) || false;
  }
  async request({ method, path, data, params, headers: reqHeaders }, options) {
    const requestOptions = __spreadProps(__spreadValues(__spreadValues({}, __privateGet(this, _options)), options), {
      headers: __spreadValues(__spreadValues({}, __privateGet(this, _options).headers), reqHeaders)
    });
    const url = new URL(requestOptions.host);
    url.pathname = url.pathname.replace(/\/$/, "") + path;
    for (const [key, value] of Object.entries(params || {})) {
      url.searchParams.append(key, Array.isArray(value) ? value.join(",") : value);
    }
    const hooks = mergeHooks(
      withRequestHeaders(requestOptions),
      withRequestTelemetry(requestOptions),
      withRequestLogging(),
      __privateGet(this, _options).hooks
    );
    return ky__default.default(url, {
      method,
      body: data && JSON.stringify(data),
      retry: {
        limit: requestOptions.maxRetries,
        methods: ["get", "post", "put", "head", "delete", "options", "trace"]
      },
      timeout: requestOptions.timeout,
      hooks
    }).then(
      (response) => response.text().then((text) => JSON.parse(text)).catch(() => void 0)
    ).catch(async (error2) => {
      var _a, _b, _c, _d;
      const body = tryParse(await ((_a = error2 == null ? void 0 : error2.response) == null ? void 0 : _a.text()));
      throw createError(__spreadValues({
        code: error2.code,
        name: error2.name,
        message: error2.message,
        type: error2["type"],
        status: (_b = error2 == null ? void 0 : error2.response) == null ? void 0 : _b.status,
        statusText: (_c = error2 == null ? void 0 : error2.response) == null ? void 0 : _c.statusText,
        responseBody: body
      }, (_d = body == null ? void 0 : body.errors) == null ? void 0 : _d[0]));
    });
  }
}
_options = new WeakMap();
const queryParamValidators = {
  archived: isBoolean,
  read: isBoolean,
  seen: isBoolean,
  categories: (value) => isString(value) || isStringArray(value),
  topics: (value) => isString(value) || isStringArray(value)
};
function isForcedQueryParams(object) {
  var _a;
  if (!isObject(object))
    return false;
  for (const key of Object.keys(object)) {
    if (!((_a = queryParamValidators[key]) == null ? void 0 : _a.call(queryParamValidators, object[key])))
      return false;
  }
  return true;
}
function getUrl(path, params, options = { encode: true }) {
  return path.replace(
    /{([\s\S]+?)}/g,
    ($0, $1) => options.encode ? encodeURIComponent(params[$1] || "") : params[$1] || ""
  );
}
function extractUrlParams(path) {
  const params = path.match(/{\w+}/g) || [];
  return (params || []).map((param) => param.replace(/[{}]/g, ""));
}
function getDataFromArgs(args) {
  if (!isArray(args) || !isObject(args[0]))
    return {};
  if (isOptionsHash(args[0]))
    return {};
  return args.shift();
}
function getOptionsFromArgs(args) {
  if (!isArray(args) || args.length === 0)
    return {};
  const arg = args[args.length - 1];
  if (!isOptionsHash(arg))
    return {};
  return __spreadValues({}, args.pop());
}
function normalizeArgs({
  path,
  method,
  args
}) {
  const argsCopy = [...args].filter((x) => x !== void 0);
  const urlParams = extractUrlParams(path);
  const urlData = urlParams.reduce((urlData2, param) => {
    const arg = argsCopy.shift();
    if (typeof arg !== "string") {
      throw new Error(
        `MagicBell: Argument "${param}" must be a string, but got ${typeof arg}: ${JSON.stringify(
          arg
        )} (on API request to \`${method} ${path}\`)`
      );
    }
    urlData2[param] = arg;
    return urlData2;
  }, {});
  const url = getUrl(path, urlData, { encode: false });
  const dataFromArgs = getDataFromArgs(argsCopy);
  const options = getOptionsFromArgs(argsCopy);
  if (argsCopy.filter((x) => x != null).length) {
    throw new Error(
      `MagicBell: Unknown arguments (${JSON.stringify(argsCopy)}). (on API request to \`${method} ${url}\`)`
    );
  }
  let dataInQuery = method === "GET";
  if (method === "POST" && isForcedQueryParams(dataFromArgs)) {
    dataInQuery = true;
  }
  const data = dataInQuery ? {} : dataFromArgs;
  const params = dataInQuery ? dataFromArgs : {};
  return { path: url, data, params, options };
}
const ASYNC_ITERATOR_SYMBOL = typeof Symbol !== "undefined" && Symbol.asyncIterator ? Symbol.asyncIterator : "@@asyncIterator";
function hasMore(pageResult, nodeCount) {
  if (!hasOwn(pageResult, "current_page") || !hasOwn(pageResult, "per_page")) {
    return false;
  }
  if (hasOwn(pageResult, "total_pages")) {
    return pageResult.current_page < pageResult.total_pages;
  }
  return nodeCount === pageResult.per_page;
}
function autoPaginate(makeRequest, { data, params }) {
  const promiseCache = { currentPromise: null };
  const reverseIteration = typeof params.after !== "undefined";
  let i = 0;
  let request = makeRequest({ data, params });
  const getNextPage = (pageResult) => {
    const page = pageResult.current_page + 1;
    return makeRequest({ data, params: __spreadProps(__spreadValues({}, params), { page }) });
  };
  function iterate(pageResult) {
    const dataKey = Object.keys(pageResult).find((key) => Array.isArray(pageResult[key]));
    const data2 = pageResult[dataKey] || pageResult.data;
    if (!data2 || typeof data2.length !== "number") {
      throw Error("Unexpected: MagicBell API response does not have a well-formed response.");
    }
    if (i < data2.length) {
      const idx = reverseIteration ? data2.length - 1 - i : i;
      const value = data2[idx];
      i += 1;
      return { value, done: false };
    }
    if (hasMore(pageResult, data2.length)) {
      i = 0;
      request = getNextPage(pageResult);
      return request.then(iterate);
    }
    return { value: void 0, done: true };
  }
  function asyncIteratorNext() {
    return memoizedPromise(promiseCache, (resolve, reject) => {
      return request.then(iterate).then(resolve).catch(reject);
    });
  }
  const forEach = makeForEach(asyncIteratorNext);
  const toArray = makeToArray(forEach);
  const autoPaginationMethods = {
    forEach,
    toArray,
    next: asyncIteratorNext,
    return: () => ({}),
    [ASYNC_ITERATOR_SYMBOL]: () => {
      return autoPaginationMethods;
    }
  };
  return Object.assign(request, autoPaginationMethods);
}
function memoizedPromise(promiseCache, cb) {
  if (promiseCache.currentPromise) {
    return promiseCache.currentPromise;
  }
  promiseCache.currentPromise = new Promise(cb).then((ret) => {
    promiseCache.currentPromise = void 0;
    return ret;
  });
  return promiseCache.currentPromise;
}
function makeForEach(asyncIteratorNext, onDoneCallback) {
  return function forEach(onItem) {
    return new Promise((resolve, reject) => {
      let idx = 0;
      function handleIteration(iterResult) {
        if (iterResult == null ? void 0 : iterResult.done) {
          resolve();
          return;
        }
        const item = iterResult == null ? void 0 : iterResult.value;
        return new Promise((resolve2) => {
          resolve2(onItem(item, idx));
        }).then((shouldContinue) => {
          if (shouldContinue === false) {
            onDoneCallback == null ? void 0 : onDoneCallback();
            return handleIteration({ done: true });
          } else {
            idx++;
            return asyncIteratorNext().then(handleIteration);
          }
        });
      }
      asyncIteratorNext().then(handleIteration).catch(reject);
    });
  };
}
function makeToArray(forEach) {
  return function toArray(options) {
    const limit = options == null ? void 0 : options.limit;
    if (!limit) {
      throw Error("You must pass a `limit` option to toArray, e.g., `toArray({ limit: 1000 });`.");
    }
    if (limit > 1e4) {
      throw Error(
        "You cannot specify a limit of more than 10,000 items to fetch in `toArray`; use `forEach` to iterate through longer lists."
      );
    }
    return new Promise((resolve, reject) => {
      const items = [];
      forEach((item) => {
        items.push(item);
        if (items.length >= limit) {
          return false;
        }
      }).then(() => {
        resolve(items);
      }).catch(reject);
    });
  };
}
function isEmptyPayload(data) {
  if (!data)
    return true;
  if (Array.isArray(data))
    return data.length === 0;
  if (typeof data === "object")
    return Object.keys(data).length === 0;
  return false;
}
class Resource {
  constructor(client) {
    __publicField(this, "path");
    __publicField(this, "entity");
    __publicField(this, "client");
    this.client = client;
  }
  request({ method, paged, path: tplPath }, ...args) {
    const { path, data, params, options } = normalizeArgs({
      path: joinUrlSegments(this.path, tplPath),
      method,
      args
    });
    const makeRequest = ({ data: data2, params: params2 }) => {
      const entity = this.entity || this.path;
      data2 = isEmptyPayload(data2) ? void 0 : { [entity]: data2 };
      params2 = isEmptyPayload(params2) ? void 0 : params2;
      return this.client.request({ method, path, data: data2, params: params2 }, options).then((response) => (response == null ? void 0 : response[entity]) || response);
    };
    if (paged) {
      return autoPaginate(makeRequest, {
        data,
        params
      });
    }
    return makeRequest({ data, params });
  }
  assertFeatureFlag(flag) {
    if (!this.client.hasFlag(flag)) {
      throw new Error(`This is a beta feature, please enable it by providing the "${flag}" feature flag.`);
    }
  }
}
class BroadcastsNotifications extends Resource {
  constructor() {
    super(...arguments);
    __publicField(this, "path", "broadcasts");
    __publicField(this, "entity", "notification");
  }
  list(broadcastId, dataOrOptions, options) {
    return this.request(
      {
        method: "GET",
        path: "{broadcast_id}/notifications",
        paged: true
      },
      broadcastId,
      dataOrOptions,
      options
    );
  }
}
class Broadcasts extends Resource {
  constructor() {
    super(...arguments);
    __publicField(this, "path", "broadcasts");
    __publicField(this, "entity", "broadcast");
    __publicField(this, "notifications", new BroadcastsNotifications(this.client));
  }
  create(data, options) {
    return this.request(
      {
        method: "POST"
      },
      data,
      options
    );
  }
  list(dataOrOptions, options) {
    return this.request(
      {
        method: "GET",
        paged: true
      },
      dataOrOptions,
      options
    );
  }
  get(broadcastId, options) {
    return this.request(
      {
        method: "GET",
        path: "{broadcast_id}"
      },
      broadcastId,
      options
    );
  }
}
class Imports extends Resource {
  constructor() {
    super(...arguments);
    __publicField(this, "path", "imports");
    __publicField(this, "entity", "import");
  }
  create(dataOrOptions, options) {
    return this.request(
      {
        method: "POST"
      },
      dataOrOptions,
      options
    );
  }
  get(importId, options) {
    return this.request(
      {
        method: "GET",
        path: "{import_id}"
      },
      importId,
      options
    );
  }
}
class MetricsCategories extends Resource {
  constructor() {
    super(...arguments);
    __publicField(this, "path", "metrics");
    __publicField(this, "entity", "categorie");
  }
  get(options) {
    return this.request(
      {
        method: "GET",
        path: "categories"
      },
      options
    );
  }
}
class MetricsTopics extends Resource {
  constructor() {
    super(...arguments);
    __publicField(this, "path", "metrics");
    __publicField(this, "entity", "topic");
  }
  get(options) {
    return this.request(
      {
        method: "GET",
        path: "topics"
      },
      options
    );
  }
}
class Metrics extends Resource {
  constructor() {
    super(...arguments);
    __publicField(this, "path", "metrics");
    __publicField(this, "entity", "metric");
    __publicField(this, "categories", new MetricsCategories(this.client));
    __publicField(this, "topics", new MetricsTopics(this.client));
  }
  get(options) {
    return this.request(
      {
        method: "GET"
      },
      options
    );
  }
}
class UsersNotifications extends Resource {
  constructor() {
    super(...arguments);
    __publicField(this, "path", "users");
    __publicField(this, "entity", "notification");
  }
  list(userId, dataOrOptions, options) {
    return this.request(
      {
        method: "GET",
        path: "{user_id}/notifications",
        paged: true
      },
      userId,
      dataOrOptions,
      options
    );
  }
}
class UsersPushSubscriptions extends Resource {
  constructor() {
    super(...arguments);
    __publicField(this, "path", "users");
    __publicField(this, "entity", "push_subscription");
  }
  list(userId, dataOrOptions, options) {
    return this.request(
      {
        method: "GET",
        path: "{user_id}/push_subscriptions",
        paged: true
      },
      userId,
      dataOrOptions,
      options
    );
  }
  delete(userId, subscriptionId, options) {
    return this.request(
      {
        method: "DELETE",
        path: "{user_id}/push_subscriptions/{subscription_id}"
      },
      userId,
      subscriptionId,
      options
    );
  }
}
class Users extends Resource {
  constructor() {
    super(...arguments);
    __publicField(this, "path", "users");
    __publicField(this, "entity", "user");
    __publicField(this, "notifications", new UsersNotifications(this.client));
    __publicField(this, "pushSubscriptions", new UsersPushSubscriptions(this.client));
  }
  create(dataOrOptions, options) {
    return this.request(
      {
        method: "POST"
      },
      dataOrOptions,
      options
    );
  }
  list(dataOrOptions, options) {
    return this.request(
      {
        method: "GET",
        paged: true
      },
      dataOrOptions,
      options
    );
  }
  get(userId, options) {
    return this.request(
      {
        method: "GET",
        path: "{user_id}"
      },
      userId,
      options
    );
  }
  update(userId, dataOrOptions, options) {
    return this.request(
      {
        method: "PUT",
        path: "{user_id}"
      },
      userId,
      dataOrOptions,
      options
    );
  }
  updateByEmail(userEmail, dataOrOptions, options) {
    return this.request(
      {
        method: "PUT",
        path: "email:{user_email}"
      },
      userEmail,
      dataOrOptions,
      options
    );
  }
  updateByExternalId(externalId, dataOrOptions, options) {
    return this.request(
      {
        method: "PUT",
        path: "external_id:{external_id}"
      },
      externalId,
      dataOrOptions,
      options
    );
  }
  delete(userId, options) {
    return this.request(
      {
        method: "DELETE",
        path: "{user_id}"
      },
      userId,
      options
    );
  }
  deleteByEmail(userEmail, options) {
    return this.request(
      {
        method: "DELETE",
        path: "email:{user_email}"
      },
      userEmail,
      options
    );
  }
  deleteByExternalId(externalId, options) {
    return this.request(
      {
        method: "DELETE",
        path: "external_id:{external_id}"
      },
      externalId,
      options
    );
  }
}
class ProjectClient extends Client {
  constructor(options) {
    assertHasRequiredOptions(options, ["apiKey", "apiSecret"]);
    super(options);
    __publicField(this, "broadcasts", new Broadcasts(this));
    __publicField(this, "imports", new Imports(this));
    __publicField(this, "metrics", new Metrics(this));
    __publicField(this, "users", new Users(this));
  }
}
exports.ProjectClient = ProjectClient;
//# sourceMappingURL=project-client.cjs.map
