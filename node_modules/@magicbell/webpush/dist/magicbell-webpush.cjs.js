/** 
 * @license @magicbell/webpush v1.4.2
 *
 * Copyright (c) MagicBell Inc. and its affiliates.
 *
 * This source code is licensed under the license found in the
 * LICENSE file in the root directory of this source tree.
 */

"use strict";
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
Object.defineProperties(exports, { __esModule: { value: true }, [Symbol.toStringTag]: { value: "Module" } });
let _config = null;
let _cacheKey = "";
const DEFAULT_HOST = "https://api.magicbell.com";
const api = {
  async getAuthToken(options) {
    const headers = {
      accept: "application/json",
      "content-type": "application/json",
      "x-magicbell-api-key": options.apiKey
    };
    if ("userExternalId" in options && options.userExternalId) {
      headers["x-magicbell-user-external-id"] = options.userExternalId;
    } else if ("userEmail" in options && options.userEmail) {
      headers["x-magicbell-user-email"] = options.userEmail;
    } else {
      throw new Error("Missing user email or external ID");
    }
    if (options.userHmac) {
      headers["x-magicbell-user-hmac"] = options.userHmac;
    }
    return fetch(`${options.host || DEFAULT_HOST}/config`, {
      method: "GET",
      headers
    }).then((x) => x.json()).then((x) => {
      const url = new URL(x.web_push_notifications.subscribe_url);
      return {
        host: options.host || DEFAULT_HOST,
        token: url.searchParams.get("access_token") || null,
        project: url.searchParams.get("project") || null
      };
    });
  },
  async getConfig({ token, project, baseURL }) {
    const cacheKey = [token, project, baseURL].join("-");
    if (_config && _cacheKey === cacheKey)
      return _config;
    return fetch(`${baseURL}/web_push_subscriptions?access_token=${token}&project=${project}`, {
      method: "GET",
      headers: {
        "Content-Type": "application/json",
        Accept: "application/json"
      }
    }).then((x) => x.json()).then((x) => {
      _config = x.push_subscription;
      _cacheKey = cacheKey;
      return _config;
    });
  },
  async getSubscriptions({ token, project, baseURL }) {
    const config = await this.getConfig({ token, project, baseURL });
    if (!config.project.api_key)
      throw new Error("Missing API key");
    const headers = {
      accept: "application/json",
      "content-type": "application/json",
      "x-magicbell-api-key": config.project.api_key
    };
    if (config.user.email) {
      headers["x-magicbell-user-email"] = config.user.email;
    } else if (config.user.external_id) {
      headers["x-magicbell-user-external-id"] = config.user.external_id;
    }
    if (config.user.hmac) {
      headers["x-magicbell-user-hmac"] = config.user.hmac;
    }
    return fetch(`${baseURL}/push_subscriptions`, {
      method: "GET",
      headers
    }).then((result) => result.json()).then((result) => (result == null ? void 0 : result.push_subscriptions) || []);
  },
  async updateSubscription({ token, project, baseURL }, subscription) {
    return fetch(`${baseURL}/web_push_subscriptions?access_token=${token}&project=${project}`, {
      method: "POST",
      headers: {
        "content-type": "application/json",
        accept: "application/json"
      },
      body: JSON.stringify({
        web_push_subscription: {
          data: subscription
        }
      })
    }).then((x) => x.json()).then((x) => x.web_push_subscription);
  }
};
function isSupported() {
  if (typeof window === "undefined" || typeof navigator === "undefined")
    return false;
  return "PushManager" in window && "serviceWorker" in navigator;
}
async function prefetchConfig(options) {
  await api.getConfig(__spreadProps(__spreadValues({}, options), { baseURL: options.host || DEFAULT_HOST }));
}
async function registerServiceWorker({ path = "/sw.js" } = {}) {
  if (navigator.serviceWorker.controller)
    return navigator.serviceWorker.ready;
  await navigator.serviceWorker.register(path);
  return navigator.serviceWorker.ready;
}
async function isSubscribed(options) {
  var _a;
  const baseURL = options.host || DEFAULT_HOST;
  const subscriptions = await api.getSubscriptions(__spreadProps(__spreadValues({}, options), { baseURL }));
  const registration = await registerServiceWorker({ path: options.serviceWorkerPath });
  const activeSubscription = await ((_a = registration == null ? void 0 : registration.pushManager) == null ? void 0 : _a.getSubscription());
  if (!(activeSubscription == null ? void 0 : activeSubscription.endpoint))
    return false;
  return subscriptions.some((subscription) => subscription.device_token === activeSubscription.endpoint);
}
async function subscribe(options) {
  if (!isSupported()) {
    throw new Error("Push notifications are not supported in this browser");
  }
  const baseURL = options.host || DEFAULT_HOST;
  const config = await api.getConfig(__spreadProps(__spreadValues({}, options), { baseURL }));
  const registration = await registerServiceWorker({ path: options.serviceWorkerPath });
  if (!(registration == null ? void 0 : registration.pushManager)) {
    throw new Error("Push notifications are not supported in this browser");
  }
  const activeSubscription = await registration.pushManager.getSubscription();
  if (activeSubscription) {
    await activeSubscription.unsubscribe().catch(() => void 0);
  }
  const applicationServerKey = config.project.vapid_public_key.replace(/=/g, "");
  const subscription = await registration.pushManager.subscribe({ userVisibleOnly: true, applicationServerKey }).then((x) => x.toJSON());
  if (!("endpoint" in subscription)) {
    throw new Error("Failed to subscribe to push notifications, browser did not return an subscription endpoint.");
  }
  await api.updateSubscription(__spreadProps(__spreadValues({}, options), { baseURL }), subscription);
}
async function getAuthToken(options) {
  return api.getAuthToken(options);
}
exports.getAuthToken = getAuthToken;
exports.isSubscribed = isSubscribed;
exports.isSupported = isSupported;
exports.prefetchConfig = prefetchConfig;
exports.registerServiceWorker = registerServiceWorker;
exports.subscribe = subscribe;
//# sourceMappingURL=magicbell-webpush.cjs.js.map
