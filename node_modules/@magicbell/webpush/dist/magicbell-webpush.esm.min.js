/** 
 * @license @magicbell/webpush v1.4.2
 *
 * Copyright (c) MagicBell Inc. and its affiliates.
 *
 * This source code is licensed under the license found in the
 * LICENSE file in the root directory of this source tree.
 */

var w = Object.defineProperty, m = Object.defineProperties;
var y = Object.getOwnPropertyDescriptors;
var l = Object.getOwnPropertySymbols;
var _ = Object.prototype.hasOwnProperty, k = Object.prototype.propertyIsEnumerable;
var b = (e, t, n) => t in e ? w(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n, a = (e, t) => {
  for (var n in t || (t = {}))
    _.call(t, n) && b(e, n, t[n]);
  if (l)
    for (var n of l(t))
      k.call(t, n) && b(e, n, t[n]);
  return e;
}, c = (e, t) => m(e, y(t));
let h = null, f = "";
const o = "https://api.magicbell.com", u = {
  async getAuthToken(e) {
    const t = {
      accept: "application/json",
      "content-type": "application/json",
      "x-magicbell-api-key": e.apiKey
    };
    if ("userExternalId" in e && e.userExternalId)
      t["x-magicbell-user-external-id"] = e.userExternalId;
    else if ("userEmail" in e && e.userEmail)
      t["x-magicbell-user-email"] = e.userEmail;
    else
      throw new Error("Missing user email or external ID");
    return e.userHmac && (t["x-magicbell-user-hmac"] = e.userHmac), fetch(`${e.host || o}/config`, {
      method: "GET",
      headers: t
    }).then((n) => n.json()).then((n) => {
      const r = new URL(n.web_push_notifications.subscribe_url);
      return {
        host: e.host || o,
        token: r.searchParams.get("access_token") || null,
        project: r.searchParams.get("project") || null
      };
    });
  },
  async getConfig({ token: e, project: t, baseURL: n }) {
    const r = [e, t, n].join("-");
    return h && f === r ? h : fetch(`${n}/web_push_subscriptions?access_token=${e}&project=${t}`, {
      method: "GET",
      headers: {
        "Content-Type": "application/json",
        Accept: "application/json"
      }
    }).then((i) => i.json()).then((i) => (h = i.push_subscription, f = r, h));
  },
  async getSubscriptions({ token: e, project: t, baseURL: n }) {
    const r = await this.getConfig({ token: e, project: t, baseURL: n });
    if (!r.project.api_key)
      throw new Error("Missing API key");
    const i = {
      accept: "application/json",
      "content-type": "application/json",
      "x-magicbell-api-key": r.project.api_key
    };
    return r.user.email ? i["x-magicbell-user-email"] = r.user.email : r.user.external_id && (i["x-magicbell-user-external-id"] = r.user.external_id), r.user.hmac && (i["x-magicbell-user-hmac"] = r.user.hmac), fetch(`${n}/push_subscriptions`, {
      method: "GET",
      headers: i
    }).then((s) => s.json()).then((s) => (s == null ? void 0 : s.push_subscriptions) || []);
  },
  async updateSubscription({ token: e, project: t, baseURL: n }, r) {
    return fetch(`${n}/web_push_subscriptions?access_token=${e}&project=${t}`, {
      method: "POST",
      headers: {
        "content-type": "application/json",
        accept: "application/json"
      },
      body: JSON.stringify({
        web_push_subscription: {
          data: r
        }
      })
    }).then((i) => i.json()).then((i) => i.web_push_subscription);
  }
};
function j() {
  return typeof window > "u" || typeof navigator > "u" ? !1 : "PushManager" in window && "serviceWorker" in navigator;
}
async function x(e) {
  await u.getConfig(c(a({}, e), { baseURL: e.host || o }));
}
async function g({ path: e = "/sw.js" } = {}) {
  return navigator.serviceWorker.controller || await navigator.serviceWorker.register(e), navigator.serviceWorker.ready;
}
async function E(e) {
  var s;
  const t = e.host || o, n = await u.getSubscriptions(c(a({}, e), { baseURL: t })), r = await g({ path: e.serviceWorkerPath }), i = await ((s = r == null ? void 0 : r.pushManager) == null ? void 0 : s.getSubscription());
  return i != null && i.endpoint ? n.some((p) => p.device_token === i.endpoint) : !1;
}
async function S(e) {
  if (!j())
    throw new Error("Push notifications are not supported in this browser");
  const t = e.host || o, n = await u.getConfig(c(a({}, e), { baseURL: t })), r = await g({ path: e.serviceWorkerPath });
  if (!(r != null && r.pushManager))
    throw new Error("Push notifications are not supported in this browser");
  const i = await r.pushManager.getSubscription();
  i && await i.unsubscribe().catch(() => {
  });
  const s = n.project.vapid_public_key.replace(/=/g, ""), p = await r.pushManager.subscribe({ userVisibleOnly: !0, applicationServerKey: s }).then((d) => d.toJSON());
  if (!("endpoint" in p))
    throw new Error("Failed to subscribe to push notifications, browser did not return an subscription endpoint.");
  await u.updateSubscription(c(a({}, e), { baseURL: t }), p);
}
async function T(e) {
  return u.getAuthToken(e);
}
export {
  T as getAuthToken,
  E as isSubscribed,
  j as isSupported,
  x as prefetchConfig,
  g as registerServiceWorker,
  S as subscribe
};
//# sourceMappingURL=magicbell-webpush.esm.min.js.map
