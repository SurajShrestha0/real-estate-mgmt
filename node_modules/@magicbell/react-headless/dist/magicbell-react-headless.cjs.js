/** 
 * @license @magicbell/react-headless v4.5.0
 *
 * Copyright (c) MagicBell Inc. and its affiliates.
 *
 * This source code is licensed under the license found in the
 * LICENSE file in the root directory of this source tree.
 */

"use strict";
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
Object.defineProperties(exports, { __esModule: { value: true }, [Symbol.toStringTag]: { value: "Module" } });
const warning = require("tiny-warning");
const jsxRuntime = require("react/jsx-runtime");
const react = require("react");
const userClient = require("magicbell/user-client");
const create = require("zustand/vanilla");
const create$1 = require("zustand");
const humps = require("humps");
const produce = require("immer");
const ramda = require("ramda");
const mitt = require("mitt");
const dayjs = require("dayjs");
const localizedFormat = require("dayjs/plugin/localizedFormat");
const relativeTime = require("dayjs/plugin/relativeTime");
const updateLocale = require("dayjs/plugin/updateLocale");
const _interopDefaultLegacy = (e) => e && typeof e === "object" && "default" in e ? e : { default: e };
const warning__default = /* @__PURE__ */ _interopDefaultLegacy(warning);
const create__default = /* @__PURE__ */ _interopDefaultLegacy(create);
const create__default$1 = /* @__PURE__ */ _interopDefaultLegacy(create$1);
const humps__default = /* @__PURE__ */ _interopDefaultLegacy(humps);
const produce__default = /* @__PURE__ */ _interopDefaultLegacy(produce);
const mitt__default = /* @__PURE__ */ _interopDefaultLegacy(mitt);
const dayjs__default = /* @__PURE__ */ _interopDefaultLegacy(dayjs);
const localizedFormat__default = /* @__PURE__ */ _interopDefaultLegacy(localizedFormat);
const relativeTime__default = /* @__PURE__ */ _interopDefaultLegacy(relativeTime);
const updateLocale__default = /* @__PURE__ */ _interopDefaultLegacy(updateLocale);
const clientSettings = create__default.default((set, get) => {
  let _client = null;
  let _key = "";
  return {
    apiKey: "",
    userEmail: void 0,
    userExternalId: void 0,
    userKey: void 0,
    clientId: Math.random().toString(36).substring(2) + Date.now(),
    serverURL: "https://api.magicbell.com",
    appInfo: void 0,
    getClient() {
      const state = get();
      const key = JSON.stringify([state.apiKey, state.userEmail, state.userExternalId, state.userKey]);
      if (key !== _key) {
        _key = key;
        _client = new userClient.UserClient({
          userExternalId: state.userExternalId,
          userEmail: state.userEmail,
          userHmac: state.userKey,
          apiKey: state.apiKey,
          host: state.serverURL,
          appInfo: state.appInfo || {
            name: "@magicbell/react-headless",
            version: "4.5.0"
          }
        });
      }
      return _client;
    }
  };
});
const clientSettings$1 = clientSettings;
function sendAPIRequest(method, path, data, params) {
  const client = clientSettings$1.getState().getClient();
  const stringParams = params ? Object.fromEntries(Object.entries(params).map(([key, value]) => [key, String(value)])) : void 0;
  return client.request({
    method,
    path,
    data,
    params: stringParams
  });
}
function fetchAPI(url, params) {
  return sendAPIRequest("GET", url, void 0, params);
}
function postAPI(url, data, params) {
  return sendAPIRequest("POST", url, data, params);
}
function deleteAPI(url, params) {
  return sendAPIRequest("DELETE", url, void 0, params);
}
function putAPI(url, data) {
  return sendAPIRequest("PUT", url, data);
}
class ConfigRepository {
  constructor(remotePathOrUrl = "/config") {
    __publicField(this, "remotePathOrUrl");
    this.remotePathOrUrl = remotePathOrUrl;
  }
  async get() {
    const json = await fetchAPI(this.remotePathOrUrl);
    return humps__default.default.camelizeKeys(json);
  }
}
const useConfig = create__default$1.default((set, get) => ({
  channels: void 0,
  inbox: void 0,
  ws: void 0,
  lastFetchedAt: void 0,
  _repository: new ConfigRepository(),
  fetch: async () => {
    const { _repository } = get();
    const json = await _repository.get();
    set(__spreadProps(__spreadValues({}, json), { lastFetchedAt: Date.now() }));
  }
}));
const useConfig$1 = useConfig;
class RemoteRepository {
  constructor(remotePathOrUrl) {
    __publicField(this, "remotePathOrUrl");
    this.remotePathOrUrl = remotePathOrUrl;
  }
  async get(id) {
    const url = `${this.remotePathOrUrl}/${id}`;
    const json = await fetchAPI(url);
    return humps__default.default.camelizeKeys(json);
  }
  async findBy(queryParams) {
    try {
      const json = await fetchAPI(this.remotePathOrUrl, queryParams);
      return humps__default.default.camelizeKeys(json);
    } catch (error) {
      if (/Network Error/.test(error.message)) {
        return;
      }
      throw error;
    }
  }
  delete(id) {
    const url = `${this.remotePathOrUrl}/${id}`;
    return deleteAPI(url).then(() => true).catch(() => false);
  }
}
class NotificationRepository extends RemoteRepository {
  constructor(remotePathOrUrl = "/notifications") {
    super(remotePathOrUrl);
  }
  archive(id) {
    const url = `${this.remotePathOrUrl}/${id}/archive`;
    return postAPI(url).then(() => true).catch(() => false);
  }
  unarchive(id) {
    const url = `${this.remotePathOrUrl}/${id}/unarchive`;
    return postAPI(url).then(() => true).catch(() => false);
  }
  markAsRead(id) {
    const url = `${this.remotePathOrUrl}/${id}/read`;
    return postAPI(url).then(() => true).catch(() => false);
  }
  markAsUnread(id) {
    const url = `${this.remotePathOrUrl}/${id}/unread`;
    return postAPI(url).then(() => true).catch(() => false);
  }
  markAllAsSeen(params) {
    const url = `${this.remotePathOrUrl}/seen`;
    return postAPI(url, void 0, params).then(() => true).catch(() => false);
  }
  markAllAsRead(params) {
    const url = `${this.remotePathOrUrl}/read`;
    return postAPI(url, void 0, params).then(() => true).catch(() => false);
  }
}
const pushEventAggregator = mitt__default.default();
const eventAggregator = mitt__default.default();
function emitEvent(event, data, source) {
  if (source === "remote") {
    pushEventAggregator.emit(event, data);
  }
  eventAggregator.emit(event, { data, source });
}
function handleAblyEvent(event) {
  const { clientId } = clientSettings$1.getState();
  const eventName = event.name.replace(/\//gi, ".");
  const eventData = event.data;
  const isLoopbackEvent = eventData.client_id && eventData.client_id === clientId;
  if (isLoopbackEvent)
    return Promise.resolve(false);
  if (typeof eventData.id === "string") {
    if (eventName === "notifications.delete") {
      emitEvent(eventName, eventData, "remote");
      return Promise.resolve(true);
    } else {
      const repository = new NotificationRepository();
      return repository.get(eventData.id).then((data) => {
        emitEvent(eventName, data.notification, "remote");
        return true;
      });
    }
  }
  emitEvent(eventName, eventData, "remote");
  return Promise.resolve(true);
}
const emptyStore = {
  context: {},
  total: 0,
  totalPages: 0,
  perPage: 0,
  currentPage: 1,
  unreadCount: 0,
  unseenCount: 0,
  notifications: []
};
function buildStore(props) {
  return __spreadValues(__spreadValues({}, emptyStore), props);
}
function setStoreProps(store, props, options = { reset: false }) {
  const _a = props, { notifications = [] } = _a, meta = __objRest(_a, ["notifications"]);
  const allNotifications = options.reset ? notifications : ramda.uniqBy(
    (notification) => notification.id,
    options.prepend ? [...notifications, ...store.notifications] : [...store.notifications, ...notifications]
  );
  return __spreadValues({ context: store.context, notifications: allNotifications }, meta);
}
function eq(value, other) {
  return value === other || value !== value && other !== other;
}
function ensureArray(value) {
  return Array.isArray(value) ? value : String(value).split(",");
}
function objMatchesContext(notification, context, comparator = eq) {
  const diff = [];
  context = __spreadValues({ archived: false }, context);
  Object.keys(context).forEach((attr) => {
    const condition = context[attr];
    if (attr === "read" && !comparator(!ramda.isNil(notification.readAt), condition) || attr === "seen" && !comparator(!ramda.isNil(notification.seenAt), condition) || attr === "archived" && !comparator(!ramda.isNil(notification.archivedAt), condition) || attr === "categories" && ensureArray(condition).every((category) => !comparator(notification.category, category)) || attr === "topics" && ensureArray(condition).every((topic) => !comparator(notification.topic, topic)) || Object.hasOwnProperty.call(notification, attr) && !comparator(notification[attr], condition)) {
      diff.push(attr);
    }
  });
  return { result: diff.length === 0, delta: diff };
}
function unix() {
  return Math.floor(Date.now() / 1e3);
}
const useNotificationStoresCollection = create__default$1.default((set, get) => ({
  stores: {},
  _repository: new NotificationRepository(),
  setStore: (storeId, defaultQueryParams = {}, otherProps = {}) => {
    set(
      produce__default.default((draft) => {
        draft.stores[storeId] = buildStore(__spreadProps(__spreadValues({}, otherProps), { context: defaultQueryParams }));
      })
    );
  },
  fetchStore: async (storeId, queryParams = {}, options = {}) => {
    const { stores, _repository } = get();
    const store = stores[storeId];
    if (store) {
      const response = await _repository.findBy(__spreadValues(__spreadValues({}, store.context), queryParams));
      if (!response)
        return;
      set(
        produce__default.default((draft) => {
          draft.stores[storeId] = setStoreProps(store, __spreadProps(__spreadValues({}, response), { lastFetchedAt: new Date() }), options);
        })
      );
    } else {
      console.error(`Store not found. Define a store with the ${storeId} ID`);
    }
  },
  fetchAllStores: async (queryParams = {}, options = {}) => {
    const { stores, fetchStore } = get();
    const storeIds = Object.keys(stores);
    const fetchers = storeIds.map((storeId) => fetchStore(storeId, queryParams, options));
    await Promise.all(fetchers);
  },
  markNotificationAsSeen: (notification) => {
    const { stores } = get();
    const notificationId = notification.id;
    emitEvent("notifications.seen", notification, "local");
    set(
      produce__default.default((draft) => {
        for (const storeId in stores) {
          const { notifications, unseenCount } = stores[storeId];
          const index = ramda.findIndex(ramda.propEq("id", notificationId), notifications);
          if (index > -1) {
            const notification2 = notifications[index];
            if (!notification2.seenAt) {
              draft.stores[storeId].unseenCount = Math.max(0, unseenCount - 1);
              draft.stores[storeId].notifications[index] = ramda.mergeRight(notifications[index], {
                seenAt: unix()
              });
            }
          }
        }
      })
    );
  },
  markNotificationAsRead: (notification) => {
    const { stores, _repository } = get();
    const { id: notificationId } = notification;
    const promise = _repository.markAsRead(notificationId);
    emitEvent("notifications.read", notification, "local");
    set(
      produce__default.default((draft) => {
        const now = unix();
        const attrs = { readAt: now, seenAt: now };
        for (const storeId in stores) {
          const { total, notifications, context, unreadCount, unseenCount } = stores[storeId];
          const index = ramda.findIndex(ramda.propEq("id", notificationId), notifications);
          if (index > -1) {
            if (!notification.readAt)
              draft.stores[storeId].unreadCount = Math.max(0, unreadCount - 1);
            if (!notification.seenAt)
              draft.stores[storeId].unseenCount = Math.max(0, unseenCount - 1);
            const readNotification = ramda.mergeRight(notifications[index], attrs);
            if (objMatchesContext(readNotification, context).result) {
              draft.stores[storeId].notifications[index] = readNotification;
            } else {
              draft.stores[storeId].total = Math.max(0, total - 1);
              draft.stores[storeId].notifications.splice(index, 1);
            }
          } else {
            const readNotification = ramda.mergeRight(notification, attrs);
            if (objMatchesContext(readNotification, context).result) {
              draft.stores[storeId].total += 1;
              draft.stores[storeId].notifications.push(readNotification);
            }
          }
        }
      })
    );
    return promise;
  },
  markNotificationAsUnread: (notification) => {
    const { stores, _repository } = get();
    const { id: notificationId } = notification;
    const promise = _repository.markAsUnread(notificationId);
    emitEvent("notifications.unread", notification, "local");
    set(
      produce__default.default((draft) => {
        const attrs = { readAt: null };
        for (const storeId in stores) {
          const { notifications, context } = stores[storeId];
          const index = ramda.findIndex(ramda.propEq("id", notificationId), notifications);
          if (index > -1) {
            const unreadNotification = ramda.mergeRight(notifications[index], attrs);
            if (objMatchesContext(unreadNotification, context).result) {
              if (notification.readAt)
                draft.stores[storeId].unreadCount += 1;
              draft.stores[storeId].notifications[index] = unreadNotification;
            } else {
              draft.stores[storeId].total = Math.max(0, draft.stores[storeId].total - 1);
              draft.stores[storeId].notifications.splice(index, 1);
            }
          } else {
            const unreadNotification = ramda.mergeRight(notification, attrs);
            if (objMatchesContext(unreadNotification, context).result) {
              draft.stores[storeId].total += 1;
              if (notification.readAt)
                draft.stores[storeId].unreadCount += 1;
              draft.stores[storeId].notifications.push(unreadNotification);
            }
          }
        }
      })
    );
    return promise;
  },
  archiveNotification: (notification, options = {}) => {
    const { stores, _repository } = get();
    const { id: notificationId } = notification;
    let promise = Promise.resolve(true);
    if (options.persist !== false) {
      promise = _repository.archive(notificationId);
      emitEvent("notifications.archived", notification, "local");
    }
    set(
      produce__default.default((draft) => {
        const now = unix();
        const attrs = { archivedAt: now };
        for (const storeId in stores) {
          const store = stores[storeId];
          const index = ramda.findIndex(ramda.propEq("id", notificationId), store.notifications);
          if (index > -1) {
            const newNotification = __spreadValues(__spreadValues({}, store.notifications[index]), attrs);
            if (objMatchesContext(newNotification, store.context).result) {
              draft.stores[storeId].notifications[index] = newNotification;
            } else {
              if (!notification.readAt)
                draft.stores[storeId].unreadCount = Math.max(0, store.unreadCount - 1);
              if (!notification.seenAt)
                draft.stores[storeId].unseenCount = Math.max(0, store.unseenCount - 1);
              draft.stores[storeId].total = Math.max(0, store.total - 1);
              draft.stores[storeId].notifications.splice(index, 1);
            }
          } else {
            const newNotification = __spreadValues(__spreadValues({}, notification), attrs);
            if (objMatchesContext(newNotification, store.context).result) {
              if (!notification.readAt)
                draft.stores[storeId].unreadCount += 1;
              if (!notification.seenAt)
                draft.stores[storeId].unseenCount += 1;
              draft.stores[storeId].total += 1;
              draft.stores[storeId].notifications.push(newNotification);
            }
          }
        }
      })
    );
    return promise;
  },
  unarchiveNotification: (notification, options = {}) => {
    const { stores, _repository } = get();
    const { id: notificationId } = notification;
    let promise = Promise.resolve(true);
    if (options.persist !== false) {
      promise = _repository.unarchive(notificationId);
      emitEvent("notifications.unarchived", notification, "local");
    }
    set(
      produce__default.default((draft) => {
        const attrs = { archivedAt: null };
        for (const storeId in stores) {
          const store = stores[storeId];
          const index = ramda.findIndex(ramda.propEq("id", notificationId), store.notifications);
          if (index > -1) {
            const newNotification = __spreadValues(__spreadValues({}, store.notifications[index]), attrs);
            if (objMatchesContext(newNotification, store.context).result) {
              draft.stores[storeId].notifications[index] = newNotification;
            } else {
              if (!notification.readAt)
                draft.stores[storeId].unreadCount = Math.max(0, store.unreadCount - 1);
              if (!notification.seenAt)
                draft.stores[storeId].unseenCount = Math.max(0, store.unseenCount - 1);
              draft.stores[storeId].total = Math.max(0, store.total - 1);
              draft.stores[storeId].notifications.splice(index, 1);
            }
          } else {
            const newNotification = __spreadValues(__spreadValues({}, notification), attrs);
            if (objMatchesContext(newNotification, store.context).result) {
              if (!notification.readAt)
                draft.stores[storeId].unreadCount += 1;
              if (!notification.seenAt)
                draft.stores[storeId].unseenCount += 1;
              draft.stores[storeId].total += 1;
              draft.stores[storeId].notifications.push(newNotification);
            }
          }
        }
      })
    );
    return promise;
  },
  deleteNotification: (notification, options = {}) => {
    const { stores, _repository } = get();
    const notificationId = notification.id;
    let promise = Promise.resolve(true);
    if (options.persist !== false) {
      promise = _repository.delete(notificationId);
      emitEvent("notifications.delete", notification, "local");
    }
    set(
      produce__default.default((draft) => {
        for (const storeId in stores) {
          const { notifications, total, unseenCount, unreadCount } = stores[storeId];
          const index = ramda.findIndex(ramda.propEq("id", notificationId), notifications);
          if (index > -1) {
            const notification2 = notifications[index];
            if (!notification2.seenAt)
              draft.stores[storeId].unseenCount = Math.max(0, unseenCount - 1);
            if (!notification2.readAt)
              draft.stores[storeId].unreadCount = Math.max(0, unreadCount - 1);
            draft.stores[storeId].total = Math.max(0, total - 1);
            draft.stores[storeId].notifications.splice(index, 1);
          }
        }
      })
    );
    return promise;
  },
  markAllAsSeen: (options = { persist: true, updateModels: true }) => {
    var _a;
    const { stores, _repository } = get();
    let promise = Promise.resolve(true);
    if (options.persist !== false) {
      const params = options.storeId ? (_a = stores[options.storeId]) == null ? void 0 : _a.context : {};
      promise = _repository.markAllAsSeen(params);
      emitEvent("notifications.seen.all", null, "local");
    }
    set(
      produce__default.default((draft) => {
        const changedNotifications = /* @__PURE__ */ new Map();
        const now = unix();
        for (const storeId in stores) {
          const { context } = stores[storeId];
          draft.stores[storeId].unseenCount = 0;
          if (options.updateModels === false)
            continue;
          if (context.seen !== true) {
            for (const notification of draft.stores[storeId].notifications) {
              if (notification.seenAt)
                continue;
              notification.seenAt = now;
              changedNotifications.set(notification.id, notification);
            }
          }
          if (context.seen === false) {
            draft.stores[storeId].notifications = [];
            draft.stores[storeId].total = 0;
          }
        }
        for (const storeId in stores) {
          const { context } = stores[storeId];
          if (context.seen !== true)
            continue;
          const notifications = draft.stores[storeId].notifications;
          for (const notification of changedNotifications.values()) {
            if (objMatchesContext(notification, context).result && !notifications.find((n) => n.id === notification.id)) {
              notifications.push(notification);
              draft.stores[storeId].total += 1;
            }
          }
        }
      })
    );
    return promise;
  },
  markAllAsRead: (options = { persist: true, updateModels: true }) => {
    var _a;
    const { stores, _repository } = get();
    let promise = Promise.resolve(true);
    if (options.persist !== false) {
      const params = options.storeId ? (_a = stores[options.storeId]) == null ? void 0 : _a.context : {};
      promise = _repository.markAllAsRead(params);
      emitEvent("notifications.read.all", null, "local");
    }
    set(
      produce__default.default((draft) => {
        const changedNotifications = /* @__PURE__ */ new Map();
        const now = unix();
        for (const storeId in stores) {
          const { context } = stores[storeId];
          draft.stores[storeId].unreadCount = 0;
          draft.stores[storeId].unseenCount = 0;
          if (options.updateModels === false)
            continue;
          if (context.read !== true) {
            for (const notification of draft.stores[storeId].notifications) {
              if (notification.readAt)
                continue;
              notification.readAt = now;
              notification.seenAt = now;
              changedNotifications.set(notification.id, notification);
            }
          }
          if (context.read === false) {
            draft.stores[storeId].notifications = [];
            draft.stores[storeId].total = 0;
          }
        }
        for (const storeId in stores) {
          const { context } = stores[storeId];
          if (context.read !== true)
            continue;
          const notifications = draft.stores[storeId].notifications;
          for (const notification of changedNotifications.values()) {
            if (objMatchesContext(notification, context).result && !notifications.find((n) => n.id === notification.id)) {
              notifications.push(notification);
              draft.stores[storeId].total += 1;
            }
          }
        }
      })
    );
    return promise;
  }
}));
const useNotificationStoresCollection$1 = useNotificationStoresCollection;
function useMagicBellEvent(event, handler, options = { source: "any" }) {
  react.useEffect(() => {
    const callback = (args = {}) => {
      if (options.source === "remote" && args.source !== "remote")
        return;
      if (options.source === "local" && args.source !== "local")
        return;
      handler(args.data, args.source);
    };
    eventAggregator.on(event, callback);
    return () => {
      eventAggregator.off(event, callback);
    };
  }, []);
}
function RealtimeListener() {
  const collection = useNotificationStoresCollection$1();
  const settings = clientSettings$1.getState();
  const client = settings.getClient();
  const apiKey = settings.apiKey;
  const user = settings.userExternalId || settings.userEmail;
  const fetchAndResetAll = () => collection.fetchAllStores({ page: 1 }, { reset: true });
  const fetchAndPrependAll = () => collection.fetchAllStores({ page: 1 }, { prepend: true });
  const markAllAsSeen = () => collection.markAllAsSeen({ persist: false });
  const markAllAsRead = () => collection.markAllAsRead({ persist: false });
  const removeNotification = (data) => collection.deleteNotification(data, { persist: false });
  const archiveNotification = (data) => collection.archiveNotification(data, { persist: false });
  const unarchiveNotification = (data) => collection.unarchiveNotification(data, { persist: false });
  react.useEffect(() => {
    if (!apiKey || !user)
      return;
    const listen = client.listen();
    listen.forEach((event) => {
      if (!event)
        return;
      void handleAblyEvent(event);
    });
    return () => listen.close();
  }, [client, apiKey, user]);
  useMagicBellEvent("reconnected", fetchAndResetAll);
  useMagicBellEvent("notifications.new", fetchAndPrependAll, { source: "remote" });
  useMagicBellEvent("notifications.seen.all", markAllAsSeen, { source: "remote" });
  useMagicBellEvent("notifications.read.all", markAllAsRead, { source: "remote" });
  useMagicBellEvent("notifications.read", fetchAndResetAll, { source: "remote" });
  useMagicBellEvent("notifications.unread", fetchAndResetAll, { source: "remote" });
  useMagicBellEvent("notifications.delete", removeNotification, { source: "remote" });
  useMagicBellEvent("notifications.archived", archiveNotification, { source: "remote" });
  useMagicBellEvent("notifications.unarchived", unarchiveNotification, { source: "remote" });
  return null;
}
function setupXHR(_a) {
  var _b = _a, { serverURL } = _b, userSettings = __objRest(_b, ["serverURL"]);
  const settings = userSettings;
  if (serverURL)
    settings.serverURL = serverURL;
  clientSettings$1.setState(settings);
  return settings;
}
function setupStores(storesConfig) {
  const stores = {};
  storesConfig.forEach((store) => {
    const { defaultQueryParams: context, defaults = {} } = store;
    stores[store.id] = buildStore(__spreadValues({ context }, defaults));
  });
  useNotificationStoresCollection$1.setState({ stores });
  return stores;
}
function MagicBellProvider(_c) {
  var _d = _c, {
    children,
    stores = [{ id: "default", defaultQueryParams: {} }],
    disableRealtime
  } = _d, clientSettings2 = __objRest(_d, [
    "children",
    "stores",
    "disableRealtime"
  ]);
  react.useState(() => setupXHR(clientSettings2));
  react.useEffect(() => {
    setupStores(stores);
  }, []);
  const config = useConfig$1();
  react.useEffect(() => {
    if (!config.lastFetchedAt)
      config.fetch();
  }, [config]);
  return /* @__PURE__ */ jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [
    disableRealtime ? null : /* @__PURE__ */ jsxRuntime.jsx(RealtimeListener, {}),
    children
  ] });
}
function stringToUint8Array(plainString) {
  const padding = "=".repeat((4 - plainString.length % 4) % 4);
  const base64 = (plainString + padding).replace(/-/g, "+").replace(/_/g, "/");
  const rawData = window.atob(base64);
  const outputArray = new Uint8Array(rawData.length);
  for (let i = 0; i < rawData.length; ++i) {
    outputArray[i] = rawData.charCodeAt(i);
  }
  return outputArray;
}
function storeSubscription(subscription) {
  const data = {
    web_push_subscription: {
      data: subscription
    }
  };
  return postAPI("/web_push_subscriptions", data);
}
function subscribeToPushNotifications(pushManager, publicKey) {
  const applicationServerKey = stringToUint8Array(publicKey);
  return pushManager.subscribe({ userVisibleOnly: true, applicationServerKey });
}
async function createPushSubscription(pushManager, config) {
  const vapidPublicKey = ramda.path(["webPush", "config", "vapidAuthentication", "publicKey"], config.channels);
  const subscription = await subscribeToPushNotifications(pushManager, vapidPublicKey);
  return storeSubscription(subscription.toJSON());
}
function createSafariPushSubscription(authenticationToken, webServiceUrl, websitePushID = "web.com.magicbell-notifications") {
  const permissionData = window["safari"].pushNotification.permission(websitePushID);
  if (permissionData.permission === "granted")
    return Promise.resolve(permissionData);
  if (permissionData.permission === "denied")
    return Promise.reject(false);
  return new Promise(function(resolve, reject) {
    window["safari"].pushNotification.requestPermission(
      webServiceUrl,
      websitePushID,
      { authenticationToken },
      function(permissionData2) {
        if (permissionData2.deviceToken) {
          const subscriptionData = {
            endpoint: permissionData2.deviceToken,
            keys: { websitePushID },
            platform: "safari"
          };
          storeSubscription(subscriptionData).then((subscription) => {
            resolve(subscription);
          }).catch((error) => {
            reject(error);
          });
        } else {
          const error = new Error("Permission was denied");
          reject(error);
        }
      }
    );
  });
}
function WebPushNotificationsSubscriber({
  children,
  serviceWorkerPath = "/service-worker.js",
  skipServiceWorkerRegistration = false
}) {
  const config = useConfig$1();
  const isSafari = "safari" in window;
  const isPushAPISupported = "PushManager" in window;
  react.useEffect(() => {
    if (!skipServiceWorkerRegistration) {
      navigator.serviceWorker.register(serviceWorkerPath);
    }
  }, [serviceWorkerPath, skipServiceWorkerRegistration]);
  const createSubscription = async () => {
    var _a, _b, _c;
    if (!config) {
      return Promise.reject(new Error("Context for MagicBell was not found"));
    }
    if (isSafari) {
      const authenticationToken = ramda.path(["safari", "authenticationToken"], (_a = config.channels) == null ? void 0 : _a.webPush.config);
      const websitePushID = ramda.path(["safari", "websitePushId"], (_b = config.channels) == null ? void 0 : _b.webPush.config);
      const webServiceUrl = ramda.path(["safari", "webServiceUrl"], (_c = config.channels) == null ? void 0 : _c.webPush.config);
      return createSafariPushSubscription(authenticationToken, webServiceUrl, websitePushID);
    }
    if (isPushAPISupported) {
      return navigator.serviceWorker.ready.then(async (registration) => {
        await createPushSubscription(registration.pushManager, config);
      });
    }
  };
  return children({ createSubscription, isPushAPISupported });
}
function useNotifications(storeId = "default") {
  const { stores, fetchStore, markAllAsSeen, markAllAsRead } = useNotificationStoresCollection$1();
  const config = useConfig$1();
  const store = stores[storeId];
  const fetch = react.useCallback(
    (queryParams, options) => fetchStore(storeId, queryParams, options),
    [fetchStore, storeId]
  );
  const fetchNextPage = react.useCallback(
    (queryParams = {}, options) => {
      const page = store.currentPage + 1;
      return fetchStore(storeId, __spreadProps(__spreadValues({}, queryParams), { page }), options);
    },
    [fetchStore, storeId, store == null ? void 0 : store.currentPage]
  );
  react.useEffect(() => {
    if (!store)
      return;
    if (config.lastFetchedAt && !store.lastFetchedAt)
      fetch({ page: 1 });
  }, [config.lastFetchedAt, store, fetch]);
  const markAllAsReadFn = react.useCallback(
    (options) => markAllAsRead(__spreadProps(__spreadValues({}, options), { storeId })),
    [markAllAsRead, storeId]
  );
  const markAllAsSeenFn = react.useCallback(
    (options) => markAllAsSeen(__spreadProps(__spreadValues({}, options), { storeId })),
    [markAllAsSeen, storeId]
  );
  if (!store)
    return null;
  return __spreadProps(__spreadValues({}, store), {
    isEmpty: store.notifications.length === 0,
    hasNextPage: store.currentPage < store.totalPages,
    fetch,
    fetchNextPage,
    markAllAsSeen: markAllAsSeenFn,
    markAllAsRead: markAllAsReadFn
  });
}
function useBell({ storeId } = {}) {
  const store = useNotifications(storeId);
  const markAllAsSeen = () => {
    if (store && store.unseenCount > 0)
      return store == null ? void 0 : store.markAllAsSeen({ updateModels: false });
    return Promise.resolve(true);
  };
  if (store)
    return __spreadProps(__spreadValues({}, store), { markAllAsSeen });
  return null;
}
dayjs__default.default.extend(localizedFormat__default.default);
dayjs__default.default.extend(relativeTime__default.default);
dayjs__default.default.extend(updateLocale__default.default);
function secondsToDate(seconds) {
  return seconds ? toDate(seconds * 1e3) : null;
}
function toDate(date) {
  return dayjs__default.default(date);
}
function toUnix(date) {
  return dayjs__default.default(date).unix();
}
function parseJSON(obj) {
  if (ramda.isNil(obj))
    return null;
  if (typeof obj === "string") {
    try {
      return JSON.parse(obj);
    } catch (e) {
    }
  }
  return obj;
}
function useNotificationFactory(data) {
  const {
    markNotificationAsRead,
    markNotificationAsSeen,
    markNotificationAsUnread,
    deleteNotification,
    archiveNotification,
    unarchiveNotification
  } = useNotificationStoresCollection$1();
  const markAsSeen = () => markNotificationAsSeen(data);
  const markAsRead = () => markNotificationAsRead(data);
  const markAsUnread = () => markNotificationAsUnread(data);
  const deleteSelf = () => deleteNotification(data);
  const archive = () => archiveNotification(data);
  const unarchive = () => unarchiveNotification(data);
  return __spreadProps(__spreadValues({}, data), {
    customAttributes: parseJSON(data.customAttributes),
    readAt: secondsToDate(data.readAt),
    seenAt: secondsToDate(data.seenAt),
    sentAt: secondsToDate(data.sentAt),
    archivedAt: secondsToDate(data.archivedAt),
    isSeen: !ramda.isNil(data.seenAt),
    isRead: !ramda.isNil(data.readAt),
    isArchived: !ramda.isNil(data.archivedAt),
    sanitizedContent: data.content,
    markAsSeen,
    markAsRead,
    markAsUnread,
    delete: deleteSelf,
    archive,
    unarchive
  });
}
function useNotificationUnmount(notification, fn) {
  react.useEffect(() => {
    return () => {
      if (fn)
        fn(notification);
      else
        notification.markAsSeen();
    };
  }, []);
}
function useNotification(data, onUnmount) {
  const notification = useNotificationFactory(data);
  useNotificationUnmount(notification, onUnmount);
  return notification;
}
class NotificationPreferencesRepository {
  constructor(remotePathOrUrl = "/notification_preferences") {
    __publicField(this, "remotePathOrUrl");
    this.remotePathOrUrl = remotePathOrUrl;
  }
  async get() {
    const url = this.remotePathOrUrl;
    const json = await fetchAPI(url);
    return humps__default.default.camelizeKeys(json);
  }
  async update(data) {
    const url = this.remotePathOrUrl;
    const payload = humps__default.default.decamelizeKeys({ notificationPreferences: data });
    const json = await putAPI(url, payload);
    return humps__default.default.camelizeKeys(json);
  }
}
const useNotificationPreferences = create__default$1.default((set, get) => ({
  categories: [],
  _repository: new NotificationPreferencesRepository(),
  fetch: async () => {
    const { _repository } = get();
    try {
      const { notificationPreferences: json } = await _repository.get();
      set(__spreadProps(__spreadValues({}, json), { lastFetchedAt: Date.now() }));
    } catch (error) {
      set({ categories: [], lastFetchedAt: Date.now() });
    }
  },
  save: async (preferences) => {
    const { _repository } = get();
    try {
      const { notificationPreferences: json } = await _repository.update(preferences);
      set(__spreadProps(__spreadValues({}, json), { lastFetchedAt: Date.now() }));
    } catch (error) {
      set({ categories: [], lastFetchedAt: Date.now() });
    }
  }
}));
const useNotificationPreferences$1 = useNotificationPreferences;
{
  const testFunc = function testFn() {
  };
  warning__default.default(
    (testFunc.name || testFunc.toString()).indexOf("testFn") !== -1,
    `It looks like you're using a minified copy of the development build of ${"@magicbell/react-headless"}. When deploying your app to production, make sure to use the production build which is faster and does not print development warnings.`
  );
}
exports.MagicBellProvider = MagicBellProvider;
exports.RealtimeListener = RealtimeListener;
exports.WebPushNotificationsSubscriber = WebPushNotificationsSubscriber;
exports.buildStore = buildStore;
exports.clientSettings = clientSettings$1;
exports.deleteAPI = deleteAPI;
exports.eventAggregator = eventAggregator;
exports.fetchAPI = fetchAPI;
exports.postAPI = postAPI;
exports.pushEventAggregator = pushEventAggregator;
exports.putAPI = putAPI;
exports.secondsToDate = secondsToDate;
exports.toDate = toDate;
exports.toUnix = toUnix;
exports.useBell = useBell;
exports.useConfig = useConfig$1;
exports.useMagicBellEvent = useMagicBellEvent;
exports.useNotification = useNotification;
exports.useNotificationFactory = useNotificationFactory;
exports.useNotificationPreferences = useNotificationPreferences$1;
exports.useNotificationStoresCollection = useNotificationStoresCollection$1;
exports.useNotificationUnmount = useNotificationUnmount;
exports.useNotifications = useNotifications;
//# sourceMappingURL=magicbell-react-headless.cjs.js.map
