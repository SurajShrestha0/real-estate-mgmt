/** 
 * @license @magicbell/react-headless v4.5.0
 *
 * Copyright (c) MagicBell Inc. and its affiliates.
 *
 * This source code is licensed under the license found in the
 * LICENSE file in the root directory of this source tree.
 */

var ee = Object.defineProperty, te = Object.defineProperties;
var ne = Object.getOwnPropertyDescriptors;
var R = Object.getOwnPropertySymbols;
var Q = Object.prototype.hasOwnProperty, G = Object.prototype.propertyIsEnumerable;
var L = (t, n, e) => n in t ? ee(t, n, { enumerable: !0, configurable: !0, writable: !0, value: e }) : t[n] = e, m = (t, n) => {
  for (var e in n || (n = {}))
    Q.call(n, e) && L(t, e, n[e]);
  if (R)
    for (var e of R(n))
      G.call(n, e) && L(t, e, n[e]);
  return t;
}, A = (t, n) => te(t, ne(n));
var _ = (t, n) => {
  var e = {};
  for (var o in t)
    Q.call(t, o) && n.indexOf(o) < 0 && (e[o] = t[o]);
  if (t != null && R)
    for (var o of R(t))
      n.indexOf(o) < 0 && G.call(t, o) && (e[o] = t[o]);
  return e;
};
var $ = (t, n, e) => (L(t, typeof n != "symbol" ? n + "" : n, e), e);
import "tiny-warning";
import { jsxs as oe, Fragment as se, jsx as re } from "react/jsx-runtime";
import { useEffect as x, useState as ie, useCallback as K } from "react";
import { UserClient as ce } from "magicbell/user-client";
import ae from "zustand/vanilla";
import J from "zustand";
import k from "humps";
import v from "immer";
import { uniqBy as ue, isNil as S, findIndex as N, propEq as b, mergeRight as U, path as F } from "ramda";
import W from "mitt";
import I from "dayjs";
import le from "dayjs/plugin/localizedFormat";
import fe from "dayjs/plugin/relativeTime";
import de from "dayjs/plugin/updateLocale";
const he = ae((t, n) => {
  let e = null, o = "";
  return {
    apiKey: "",
    userEmail: void 0,
    userExternalId: void 0,
    userKey: void 0,
    clientId: Math.random().toString(36).substring(2) + Date.now(),
    serverURL: "https://api.magicbell.com",
    appInfo: void 0,
    getClient() {
      const s = n(), i = JSON.stringify([s.apiKey, s.userEmail, s.userExternalId, s.userKey]);
      return i !== o && (o = i, e = new ce({
        userExternalId: s.userExternalId,
        userEmail: s.userEmail,
        userHmac: s.userKey,
        apiKey: s.apiKey,
        host: s.serverURL,
        appInfo: s.appInfo || {
          name: "@magicbell/react-headless",
          version: "4.5.0"
        }
      })), e;
    }
  };
}), T = he;
function z(t, n, e, o) {
  const s = T.getState().getClient(), i = o ? Object.fromEntries(Object.entries(o).map(([c, r]) => [c, String(r)])) : void 0;
  return s.request({
    method: t,
    path: n,
    data: e,
    params: i
  });
}
function D(t, n) {
  return z("GET", t, void 0, n);
}
function w(t, n, e) {
  return z("POST", t, n, e);
}
function me(t, n) {
  return z("DELETE", t, void 0, n);
}
function pe(t, n) {
  return z("PUT", t, n);
}
class Ae {
  constructor(n = "/config") {
    $(this, "remotePathOrUrl");
    this.remotePathOrUrl = n;
  }
  async get() {
    const n = await D(this.remotePathOrUrl);
    return k.camelizeKeys(n);
  }
}
const ye = J((t, n) => ({
  channels: void 0,
  inbox: void 0,
  ws: void 0,
  lastFetchedAt: void 0,
  _repository: new Ae(),
  fetch: async () => {
    const { _repository: e } = n(), o = await e.get();
    t(A(m({}, o), { lastFetchedAt: Date.now() }));
  }
})), H = ye;
class ve {
  constructor(n) {
    $(this, "remotePathOrUrl");
    this.remotePathOrUrl = n;
  }
  async get(n) {
    const e = `${this.remotePathOrUrl}/${n}`, o = await D(e);
    return k.camelizeKeys(o);
  }
  async findBy(n) {
    try {
      const e = await D(this.remotePathOrUrl, n);
      return k.camelizeKeys(e);
    } catch (e) {
      if (/Network Error/.test(e.message))
        return;
      throw e;
    }
  }
  delete(n) {
    const e = `${this.remotePathOrUrl}/${n}`;
    return me(e).then(() => !0).catch(() => !1);
  }
}
class X extends ve {
  constructor(n = "/notifications") {
    super(n);
  }
  archive(n) {
    const e = `${this.remotePathOrUrl}/${n}/archive`;
    return w(e).then(() => !0).catch(() => !1);
  }
  unarchive(n) {
    const e = `${this.remotePathOrUrl}/${n}/unarchive`;
    return w(e).then(() => !0).catch(() => !1);
  }
  markAsRead(n) {
    const e = `${this.remotePathOrUrl}/${n}/read`;
    return w(e).then(() => !0).catch(() => !1);
  }
  markAsUnread(n) {
    const e = `${this.remotePathOrUrl}/${n}/unread`;
    return w(e).then(() => !0).catch(() => !1);
  }
  markAllAsSeen(n) {
    const e = `${this.remotePathOrUrl}/seen`;
    return w(e, void 0, n).then(() => !0).catch(() => !1);
  }
  markAllAsRead(n) {
    const e = `${this.remotePathOrUrl}/read`;
    return w(e, void 0, n).then(() => !0).catch(() => !1);
  }
}
const Pe = W(), q = W();
function y(t, n, e) {
  e === "remote" && Pe.emit(t, n), q.emit(t, { data: n, source: e });
}
function ge(t) {
  const { clientId: n } = T.getState(), e = t.name.replace(/\//gi, "."), o = t.data;
  return o.client_id && o.client_id === n ? Promise.resolve(!1) : typeof o.id == "string" ? e === "notifications.delete" ? (y(e, o, "remote"), Promise.resolve(!0)) : new X().get(o.id).then((c) => (y(e, c.notification, "remote"), !0)) : (y(e, o, "remote"), Promise.resolve(!0));
}
const we = {
  context: {},
  total: 0,
  totalPages: 0,
  perPage: 0,
  currentPage: 1,
  unreadCount: 0,
  unseenCount: 0,
  notifications: []
};
function Y(t) {
  return m(m({}, we), t);
}
function Se(t, n, e = { reset: !1 }) {
  const c = n, { notifications: o = [] } = c, s = _(c, ["notifications"]), i = e.reset ? o : ue(
    (r) => r.id,
    e.prepend ? [...o, ...t.notifications] : [...t.notifications, ...o]
  );
  return m({ context: t.context, notifications: i }, s);
}
function xe(t, n) {
  return t === n || t !== t && n !== n;
}
function V(t) {
  return Array.isArray(t) ? t : String(t).split(",");
}
function P(t, n, e = xe) {
  const o = [];
  return n = m({ archived: !1 }, n), Object.keys(n).forEach((s) => {
    const i = n[s];
    (s === "read" && !e(!S(t.readAt), i) || s === "seen" && !e(!S(t.seenAt), i) || s === "archived" && !e(!S(t.archivedAt), i) || s === "categories" && V(i).every((c) => !e(t.category, c)) || s === "topics" && V(i).every((c) => !e(t.topic, c)) || Object.hasOwnProperty.call(t, s) && !e(t[s], i)) && o.push(s);
  }), { result: o.length === 0, delta: o };
}
function E() {
  return Math.floor(Date.now() / 1e3);
}
const Ne = J((t, n) => ({
  stores: {},
  _repository: new X(),
  setStore: (e, o = {}, s = {}) => {
    t(
      v((i) => {
        i.stores[e] = Y(A(m({}, s), { context: o }));
      })
    );
  },
  fetchStore: async (e, o = {}, s = {}) => {
    const { stores: i, _repository: c } = n(), r = i[e];
    if (r) {
      const u = await c.findBy(m(m({}, r.context), o));
      if (!u)
        return;
      t(
        v((d) => {
          d.stores[e] = Se(r, A(m({}, u), { lastFetchedAt: new Date() }), s);
        })
      );
    } else
      console.error(`Store not found. Define a store with the ${e} ID`);
  },
  fetchAllStores: async (e = {}, o = {}) => {
    const { stores: s, fetchStore: i } = n(), r = Object.keys(s).map((u) => i(u, e, o));
    await Promise.all(r);
  },
  markNotificationAsSeen: (e) => {
    const { stores: o } = n(), s = e.id;
    y("notifications.seen", e, "local"), t(
      v((i) => {
        for (const c in o) {
          const { notifications: r, unseenCount: u } = o[c], d = N(b("id", s), r);
          d > -1 && (r[d].seenAt || (i.stores[c].unseenCount = Math.max(0, u - 1), i.stores[c].notifications[d] = U(r[d], {
            seenAt: E()
          })));
        }
      })
    );
  },
  markNotificationAsRead: (e) => {
    const { stores: o, _repository: s } = n(), { id: i } = e, c = s.markAsRead(i);
    return y("notifications.read", e, "local"), t(
      v((r) => {
        const u = E(), d = { readAt: u, seenAt: u };
        for (const a in o) {
          const { total: f, notifications: l, context: h, unreadCount: p, unseenCount: O } = o[a], M = N(b("id", i), l);
          if (M > -1) {
            e.readAt || (r.stores[a].unreadCount = Math.max(0, p - 1)), e.seenAt || (r.stores[a].unseenCount = Math.max(0, O - 1));
            const C = U(l[M], d);
            P(C, h).result ? r.stores[a].notifications[M] = C : (r.stores[a].total = Math.max(0, f - 1), r.stores[a].notifications.splice(M, 1));
          } else {
            const C = U(e, d);
            P(C, h).result && (r.stores[a].total += 1, r.stores[a].notifications.push(C));
          }
        }
      })
    ), c;
  },
  markNotificationAsUnread: (e) => {
    const { stores: o, _repository: s } = n(), { id: i } = e, c = s.markAsUnread(i);
    return y("notifications.unread", e, "local"), t(
      v((r) => {
        const u = { readAt: null };
        for (const d in o) {
          const { notifications: a, context: f } = o[d], l = N(b("id", i), a);
          if (l > -1) {
            const h = U(a[l], u);
            P(h, f).result ? (e.readAt && (r.stores[d].unreadCount += 1), r.stores[d].notifications[l] = h) : (r.stores[d].total = Math.max(0, r.stores[d].total - 1), r.stores[d].notifications.splice(l, 1));
          } else {
            const h = U(e, u);
            P(h, f).result && (r.stores[d].total += 1, e.readAt && (r.stores[d].unreadCount += 1), r.stores[d].notifications.push(h));
          }
        }
      })
    ), c;
  },
  archiveNotification: (e, o = {}) => {
    const { stores: s, _repository: i } = n(), { id: c } = e;
    let r = Promise.resolve(!0);
    return o.persist !== !1 && (r = i.archive(c), y("notifications.archived", e, "local")), t(
      v((u) => {
        const a = { archivedAt: E() };
        for (const f in s) {
          const l = s[f], h = N(b("id", c), l.notifications);
          if (h > -1) {
            const p = m(m({}, l.notifications[h]), a);
            P(p, l.context).result ? u.stores[f].notifications[h] = p : (e.readAt || (u.stores[f].unreadCount = Math.max(0, l.unreadCount - 1)), e.seenAt || (u.stores[f].unseenCount = Math.max(0, l.unseenCount - 1)), u.stores[f].total = Math.max(0, l.total - 1), u.stores[f].notifications.splice(h, 1));
          } else {
            const p = m(m({}, e), a);
            P(p, l.context).result && (e.readAt || (u.stores[f].unreadCount += 1), e.seenAt || (u.stores[f].unseenCount += 1), u.stores[f].total += 1, u.stores[f].notifications.push(p));
          }
        }
      })
    ), r;
  },
  unarchiveNotification: (e, o = {}) => {
    const { stores: s, _repository: i } = n(), { id: c } = e;
    let r = Promise.resolve(!0);
    return o.persist !== !1 && (r = i.unarchive(c), y("notifications.unarchived", e, "local")), t(
      v((u) => {
        const d = { archivedAt: null };
        for (const a in s) {
          const f = s[a], l = N(b("id", c), f.notifications);
          if (l > -1) {
            const h = m(m({}, f.notifications[l]), d);
            P(h, f.context).result ? u.stores[a].notifications[l] = h : (e.readAt || (u.stores[a].unreadCount = Math.max(0, f.unreadCount - 1)), e.seenAt || (u.stores[a].unseenCount = Math.max(0, f.unseenCount - 1)), u.stores[a].total = Math.max(0, f.total - 1), u.stores[a].notifications.splice(l, 1));
          } else {
            const h = m(m({}, e), d);
            P(h, f.context).result && (e.readAt || (u.stores[a].unreadCount += 1), e.seenAt || (u.stores[a].unseenCount += 1), u.stores[a].total += 1, u.stores[a].notifications.push(h));
          }
        }
      })
    ), r;
  },
  deleteNotification: (e, o = {}) => {
    const { stores: s, _repository: i } = n(), c = e.id;
    let r = Promise.resolve(!0);
    return o.persist !== !1 && (r = i.delete(c), y("notifications.delete", e, "local")), t(
      v((u) => {
        for (const d in s) {
          const { notifications: a, total: f, unseenCount: l, unreadCount: h } = s[d], p = N(b("id", c), a);
          if (p > -1) {
            const O = a[p];
            O.seenAt || (u.stores[d].unseenCount = Math.max(0, l - 1)), O.readAt || (u.stores[d].unreadCount = Math.max(0, h - 1)), u.stores[d].total = Math.max(0, f - 1), u.stores[d].notifications.splice(p, 1);
          }
        }
      })
    ), r;
  },
  markAllAsSeen: (e = { persist: !0, updateModels: !0 }) => {
    var c;
    const { stores: o, _repository: s } = n();
    let i = Promise.resolve(!0);
    if (e.persist !== !1) {
      const r = e.storeId ? (c = o[e.storeId]) == null ? void 0 : c.context : {};
      i = s.markAllAsSeen(r), y("notifications.seen.all", null, "local");
    }
    return t(
      v((r) => {
        const u = /* @__PURE__ */ new Map(), d = E();
        for (const a in o) {
          const { context: f } = o[a];
          if (r.stores[a].unseenCount = 0, e.updateModels !== !1) {
            if (f.seen !== !0)
              for (const l of r.stores[a].notifications)
                l.seenAt || (l.seenAt = d, u.set(l.id, l));
            f.seen === !1 && (r.stores[a].notifications = [], r.stores[a].total = 0);
          }
        }
        for (const a in o) {
          const { context: f } = o[a];
          if (f.seen !== !0)
            continue;
          const l = r.stores[a].notifications;
          for (const h of u.values())
            P(h, f).result && !l.find((p) => p.id === h.id) && (l.push(h), r.stores[a].total += 1);
        }
      })
    ), i;
  },
  markAllAsRead: (e = { persist: !0, updateModels: !0 }) => {
    var c;
    const { stores: o, _repository: s } = n();
    let i = Promise.resolve(!0);
    if (e.persist !== !1) {
      const r = e.storeId ? (c = o[e.storeId]) == null ? void 0 : c.context : {};
      i = s.markAllAsRead(r), y("notifications.read.all", null, "local");
    }
    return t(
      v((r) => {
        const u = /* @__PURE__ */ new Map(), d = E();
        for (const a in o) {
          const { context: f } = o[a];
          if (r.stores[a].unreadCount = 0, r.stores[a].unseenCount = 0, e.updateModels !== !1) {
            if (f.read !== !0)
              for (const l of r.stores[a].notifications)
                l.readAt || (l.readAt = d, l.seenAt = d, u.set(l.id, l));
            f.read === !1 && (r.stores[a].notifications = [], r.stores[a].total = 0);
          }
        }
        for (const a in o) {
          const { context: f } = o[a];
          if (f.read !== !0)
            continue;
          const l = r.stores[a].notifications;
          for (const h of u.values())
            P(h, f).result && !l.find((p) => p.id === h.id) && (l.push(h), r.stores[a].total += 1);
        }
      })
    ), i;
  }
})), B = Ne;
function g(t, n, e = { source: "any" }) {
  x(() => {
    const o = (s = {}) => {
      e.source === "remote" && s.source !== "remote" || e.source === "local" && s.source !== "local" || n(s.data, s.source);
    };
    return q.on(t, o), () => {
      q.off(t, o);
    };
  }, []);
}
function be() {
  const t = B(), n = T.getState(), e = n.getClient(), o = n.apiKey, s = n.userExternalId || n.userEmail, i = () => t.fetchAllStores({ page: 1 }, { reset: !0 }), c = () => t.fetchAllStores({ page: 1 }, { prepend: !0 }), r = () => t.markAllAsSeen({ persist: !1 }), u = () => t.markAllAsRead({ persist: !1 }), d = (l) => t.deleteNotification(l, { persist: !1 }), a = (l) => t.archiveNotification(l, { persist: !1 }), f = (l) => t.unarchiveNotification(l, { persist: !1 });
  return x(() => {
    if (!o || !s)
      return;
    const l = e.listen();
    return l.forEach((h) => {
      !h || ge(h);
    }), () => l.close();
  }, [e, o, s]), g("reconnected", i), g("notifications.new", c, { source: "remote" }), g("notifications.seen.all", r, { source: "remote" }), g("notifications.read.all", u, { source: "remote" }), g("notifications.read", i, { source: "remote" }), g("notifications.unread", i, { source: "remote" }), g("notifications.delete", d, { source: "remote" }), g("notifications.archived", a, { source: "remote" }), g("notifications.unarchived", f, { source: "remote" }), null;
}
function ke(e) {
  var o = e, { serverURL: t } = o, n = _(o, ["serverURL"]);
  const s = n;
  return t && (s.serverURL = t), T.setState(s), s;
}
function Ce(t) {
  const n = {};
  return t.forEach((e) => {
    const { defaultQueryParams: o, defaults: s = {} } = e;
    n[e.id] = Y(m({ context: o }, s));
  }), B.setState({ stores: n }), n;
}
function et(s) {
  var i = s, {
    children: t,
    stores: n = [{ id: "default", defaultQueryParams: {} }],
    disableRealtime: e
  } = i, o = _(i, [
    "children",
    "stores",
    "disableRealtime"
  ]);
  ie(() => ke(o)), x(() => {
    Ce(n);
  }, []);
  const c = H();
  return x(() => {
    c.lastFetchedAt || c.fetch();
  }, [c]), /* @__PURE__ */ oe(se, { children: [
    e ? null : /* @__PURE__ */ re(be, {}),
    t
  ] });
}
function Ue(t) {
  const n = "=".repeat((4 - t.length % 4) % 4), e = (t + n).replace(/-/g, "+").replace(/_/g, "/"), o = window.atob(e), s = new Uint8Array(o.length);
  for (let i = 0; i < o.length; ++i)
    s[i] = o.charCodeAt(i);
  return s;
}
function Z(t) {
  return w("/web_push_subscriptions", {
    web_push_subscription: {
      data: t
    }
  });
}
function Ee(t, n) {
  const e = Ue(n);
  return t.subscribe({ userVisibleOnly: !0, applicationServerKey: e });
}
async function Ie(t, n) {
  const e = F(["webPush", "config", "vapidAuthentication", "publicKey"], n.channels), o = await Ee(t, e);
  return Z(o.toJSON());
}
function Oe(t, n, e = "web.com.magicbell-notifications") {
  const o = window.safari.pushNotification.permission(e);
  return o.permission === "granted" ? Promise.resolve(o) : o.permission === "denied" ? Promise.reject(!1) : new Promise(function(s, i) {
    window.safari.pushNotification.requestPermission(
      n,
      e,
      { authenticationToken: t },
      function(c) {
        if (c.deviceToken) {
          const r = {
            endpoint: c.deviceToken,
            keys: { websitePushID: e },
            platform: "safari"
          };
          Z(r).then((u) => {
            s(u);
          }).catch((u) => {
            i(u);
          });
        } else {
          const r = new Error("Permission was denied");
          i(r);
        }
      }
    );
  });
}
function tt({
  children: t,
  serviceWorkerPath: n = "/service-worker.js",
  skipServiceWorkerRegistration: e = !1
}) {
  const o = H(), s = "safari" in window, i = "PushManager" in window;
  return x(() => {
    e || navigator.serviceWorker.register(n);
  }, [n, e]), t({ createSubscription: async () => {
    var r, u, d;
    if (!o)
      return Promise.reject(new Error("Context for MagicBell was not found"));
    if (s) {
      const a = F(["safari", "authenticationToken"], (r = o.channels) == null ? void 0 : r.webPush.config), f = F(["safari", "websitePushId"], (u = o.channels) == null ? void 0 : u.webPush.config), l = F(["safari", "webServiceUrl"], (d = o.channels) == null ? void 0 : d.webPush.config);
      return Oe(a, l, f);
    }
    if (i)
      return navigator.serviceWorker.ready.then(async (a) => {
        await Ie(a.pushManager, o);
      });
  }, isPushAPISupported: i });
}
function Me(t = "default") {
  const { stores: n, fetchStore: e, markAllAsSeen: o, markAllAsRead: s } = B(), i = H(), c = n[t], r = K(
    (f, l) => e(t, f, l),
    [e, t]
  ), u = K(
    (f = {}, l) => {
      const h = c.currentPage + 1;
      return e(t, A(m({}, f), { page: h }), l);
    },
    [e, t, c == null ? void 0 : c.currentPage]
  );
  x(() => {
    !c || i.lastFetchedAt && !c.lastFetchedAt && r({ page: 1 });
  }, [i.lastFetchedAt, c, r]);
  const d = K(
    (f) => s(A(m({}, f), { storeId: t })),
    [s, t]
  ), a = K(
    (f) => o(A(m({}, f), { storeId: t })),
    [o, t]
  );
  return c ? A(m({}, c), {
    isEmpty: c.notifications.length === 0,
    hasNextPage: c.currentPage < c.totalPages,
    fetch: r,
    fetchNextPage: u,
    markAllAsSeen: a,
    markAllAsRead: d
  }) : null;
}
function nt({ storeId: t } = {}) {
  const n = Me(t), e = () => n && n.unseenCount > 0 ? n == null ? void 0 : n.markAllAsSeen({ updateModels: !1 }) : Promise.resolve(!0);
  return n ? A(m({}, n), { markAllAsSeen: e }) : null;
}
I.extend(le);
I.extend(fe);
I.extend(de);
function j(t) {
  return t ? Re(t * 1e3) : null;
}
function Re(t) {
  return I(t);
}
function ot(t) {
  return I(t).unix();
}
function _e(t) {
  if (S(t))
    return null;
  if (typeof t == "string")
    try {
      return JSON.parse(t);
    } catch (n) {
    }
  return t;
}
function $e(t) {
  const {
    markNotificationAsRead: n,
    markNotificationAsSeen: e,
    markNotificationAsUnread: o,
    deleteNotification: s,
    archiveNotification: i,
    unarchiveNotification: c
  } = B(), r = () => e(t), u = () => n(t), d = () => o(t), a = () => s(t), f = () => i(t), l = () => c(t);
  return A(m({}, t), {
    customAttributes: _e(t.customAttributes),
    readAt: j(t.readAt),
    seenAt: j(t.seenAt),
    sentAt: j(t.sentAt),
    archivedAt: j(t.archivedAt),
    isSeen: !S(t.seenAt),
    isRead: !S(t.readAt),
    isArchived: !S(t.archivedAt),
    sanitizedContent: t.content,
    markAsSeen: r,
    markAsRead: u,
    markAsUnread: d,
    delete: a,
    archive: f,
    unarchive: l
  });
}
function Ke(t, n) {
  x(() => () => {
    n ? n(t) : t.markAsSeen();
  }, []);
}
function st(t, n) {
  const e = $e(t);
  return Ke(e, n), e;
}
class je {
  constructor(n = "/notification_preferences") {
    $(this, "remotePathOrUrl");
    this.remotePathOrUrl = n;
  }
  async get() {
    const n = this.remotePathOrUrl, e = await D(n);
    return k.camelizeKeys(e);
  }
  async update(n) {
    const e = this.remotePathOrUrl, o = k.decamelizeKeys({ notificationPreferences: n }), s = await pe(e, o);
    return k.camelizeKeys(s);
  }
}
const Fe = J((t, n) => ({
  categories: [],
  _repository: new je(),
  fetch: async () => {
    const { _repository: e } = n();
    try {
      const { notificationPreferences: o } = await e.get();
      t(A(m({}, o), { lastFetchedAt: Date.now() }));
    } catch (o) {
      t({ categories: [], lastFetchedAt: Date.now() });
    }
  },
  save: async (e) => {
    const { _repository: o } = n();
    try {
      const { notificationPreferences: s } = await o.update(e);
      t(A(m({}, s), { lastFetchedAt: Date.now() }));
    } catch (s) {
      t({ categories: [], lastFetchedAt: Date.now() });
    }
  }
})), rt = Fe;
export {
  et as MagicBellProvider,
  be as RealtimeListener,
  tt as WebPushNotificationsSubscriber,
  Y as buildStore,
  T as clientSettings,
  me as deleteAPI,
  q as eventAggregator,
  D as fetchAPI,
  w as postAPI,
  Pe as pushEventAggregator,
  pe as putAPI,
  j as secondsToDate,
  Re as toDate,
  ot as toUnix,
  nt as useBell,
  H as useConfig,
  g as useMagicBellEvent,
  st as useNotification,
  $e as useNotificationFactory,
  rt as useNotificationPreferences,
  B as useNotificationStoresCollection,
  Ke as useNotificationUnmount,
  Me as useNotifications
};
//# sourceMappingURL=magicbell-react-headless.esm.min.js.map
