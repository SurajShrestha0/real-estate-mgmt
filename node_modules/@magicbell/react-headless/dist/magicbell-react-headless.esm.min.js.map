{"version":3,"file":"magicbell-react-headless.esm.min.js","sources":["../src/stores/clientSettings.ts","../src/lib/ajax.ts","../src/stores/config/ConfigRepository.ts","../src/stores/config/useConfig.ts","../src/stores/repository/RemoteRepository.ts","../src/stores/notifications/NotificationRepository.ts","../src/lib/realtime.ts","../src/stores/notifications/helpers/buildStore.ts","../src/stores/notifications/helpers/setStoreProps.ts","../src/stores/notifications/helpers/strategies.ts","../src/stores/notifications/useNotificationStoresCollection.ts","../src/hooks/useMagicBellEvent.ts","../src/components/RealtimeListener.tsx","../src/components/MagicBellProvider/MagicBellProvider.tsx","../src/lib/push.ts","../src/components/WebPushNotificationsSubscriber/WebPushNotificationsSubscriber.tsx","../src/hooks/useNotifications.ts","../src/hooks/useBell.ts","../src/lib/date.ts","../src/lib/json.ts","../src/hooks/useNotificationFactory.ts","../src/hooks/useNotificationUnmount.ts","../src/hooks/useNotification.ts","../src/stores/notification_preferences/NotificationPreferencesRepository.ts","../src/stores/notification_preferences/useNotificationPreferences.tsx"],"sourcesContent":["import { UserClient } from 'magicbell/user-client';\nimport create from 'zustand/vanilla';\n\nexport type ClientSettings = {\n  apiKey: string;\n  userEmail?: string;\n  userExternalId?: string;\n  userKey?: string;\n  clientId: string;\n  serverURL: string;\n  getClient(): InstanceType<typeof UserClient>;\n  appInfo?: { name: string; version: string };\n} & ({ userEmail: string } | { userExternalId: string });\n\n/**\n * Store for the configuration of this MagicBell client. It contains all\n * settings required to make a request to the MagicBell server.\n *\n * @example\n * const { apiKey } = clientSettings.getState()\n */\nconst clientSettings = create<ClientSettings>((set, get) => {\n  let _client: InstanceType<typeof UserClient> | null = null;\n  let _key = '';\n\n  return {\n    apiKey: '',\n    userEmail: undefined,\n    userExternalId: undefined,\n    userKey: undefined,\n    clientId: Math.random().toString(36).substring(2) + Date.now(),\n    serverURL: 'https://api.magicbell.com',\n    appInfo: undefined,\n\n    getClient() {\n      const state = get();\n      const key = JSON.stringify([state.apiKey, state.userEmail, state.userExternalId, state.userKey]);\n\n      if (key !== _key) {\n        _key = key;\n        _client = new UserClient({\n          userExternalId: state.userExternalId,\n          userEmail: state.userEmail,\n          userHmac: state.userKey,\n          apiKey: state.apiKey,\n          host: state.serverURL,\n          appInfo: state.appInfo || {\n            name: __PACKAGE_NAME__,\n            version: __PACKAGE_VERSION__,\n          },\n        });\n      }\n\n      return _client;\n    },\n  };\n});\n\nexport default clientSettings;\n","import clientSettings from '../stores/clientSettings';\n\n/**\n * Performs an ajax request to the MagicBell API server.\n *\n * @param method - the request method to be used when making the request\n * @param path - the server URL that will be used for the request\n * @param data - the data to be sent as the request body\n * @param params - the URL parameters to be sent with the request\n */\nfunction sendAPIRequest(\n  method: 'GET' | 'POST' | 'PUT' | 'PATCH' | 'DELETE',\n  path: string,\n  data?: Record<string, unknown>,\n  params?: Record<string, unknown>,\n): Promise<unknown> {\n  const client = clientSettings.getState().getClient();\n\n  const stringParams = params\n    ? Object.fromEntries<string>(Object.entries(params).map(([key, value]) => [key, String(value)]))\n    : undefined;\n\n  return client.request({\n    method,\n    path,\n    data,\n    params: stringParams,\n  });\n}\n\n/**\n * Performs a GET request.\n *\n * @param url - the server URL that will be used for the request\n * @param params - the URL parameters to be sent with the request\n */\nexport function fetchAPI(url: string, params?: Record<string, unknown>) {\n  return sendAPIRequest('GET', url, undefined, params);\n}\n\n/**\n * Performs a POST request.\n *\n * @param url - the server URL that will be used for the request\n * @param data - the data to be sent as the request body\n * @param params - the URL parameters to be sent with the request\n */\nexport function postAPI(url: string, data?: Record<string, unknown>, params?: Record<string, unknown>) {\n  return sendAPIRequest('POST', url, data, params);\n}\n\n/**\n * Performs a DELETE request.\n *\n * @param url - the server URL that will be used for the request\n * @param params - the URL parameters to be sent with the request\n */\nexport function deleteAPI(url: string, params?: Record<string, unknown>) {\n  return sendAPIRequest('DELETE', url, undefined, params);\n}\n\n/**\n * Performs a PUT request.\n *\n * @param url - the server URL that will be used for the request\n * @param data - the data to be sent as the request body\n * @param params - the URL parameters to be sent with the request\n * @returns - A promise.\n */\nexport function putAPI(url: string, data: Record<string, unknown>) {\n  return sendAPIRequest('PUT', url, data);\n}\n","import humps from 'humps';\n\nimport { fetchAPI } from '../../lib/ajax';\nimport IRemoteConfig from '../../types/IRemoteConfig';\n\n/**\n * Class to interact with the config API endpoint.\n *\n * @example\n * const repo = new ConfigRepository();\n * const config = await repo.get();\n */\nexport default class ConfigRepository {\n  remotePathOrUrl: string;\n\n  constructor(remotePathOrUrl = '/config') {\n    this.remotePathOrUrl = remotePathOrUrl;\n  }\n\n  /**\n   * Get the configuration from the API server.\n   */\n  async get(): Promise<IRemoteConfig> {\n    const json = await fetchAPI(this.remotePathOrUrl);\n    return humps.camelizeKeys(json);\n  }\n}\n","import create from 'zustand';\n\nimport IRemoteConfig from '../../types/IRemoteConfig';\nimport ConfigRepository from './ConfigRepository';\n\ninterface Config extends IRemoteConfig {\n  lastFetchedAt?: number;\n\n  /**\n   * Fetch the configuration for the current user from the MagicBell server.\n   */\n  fetch: () => Promise<void>;\n\n  _repository: ConfigRepository;\n}\n\n/**\n * Remote configuration store. It contains all settings stored in MagicBell\n * servers for this user.\n *\n * @example\n * const { fetch } = useConfig();\n * useEffect(() => fetch(), []);\n */\nconst useConfig = create<Config>((set, get) => ({\n  channels: undefined,\n  inbox: undefined,\n  ws: undefined,\n  lastFetchedAt: undefined,\n\n  _repository: new ConfigRepository(),\n\n  fetch: async () => {\n    const { _repository } = get();\n    const json = await _repository.get();\n\n    set({ ...json, lastFetchedAt: Date.now() });\n  },\n}));\n\nexport default useConfig;\n","import humps from 'humps';\n\nimport { deleteAPI, fetchAPI } from '../../lib/ajax';\nimport { QueryParams } from '../../types/INotificationsStoresCollection';\n\n/**\n * Class to represent a client that interacts with the MagicBell API.\n *\n * @example\n * class NotificationRepo extends RemoteRepository<Notification, NotificationStore> {}\n */\nexport default abstract class RemoteRepository<Item, Collection> {\n  remotePathOrUrl: string;\n\n  constructor(remotePathOrUrl: string) {\n    this.remotePathOrUrl = remotePathOrUrl;\n  }\n\n  /**\n   * Get an element from the API server by ID.\n   *\n   * @example\n   * const notification = await repo.get('3df592eb-5f09dd6b');\n   */\n  async get(id: string | number): Promise<Item> {\n    const url = `${this.remotePathOrUrl}/${id}`;\n    const json = await fetchAPI(url);\n\n    return humps.camelizeKeys(json) as Item;\n  }\n\n  /**\n   * Get elements that match params from the API server.\n   *\n   * @example\n   * const notifications = await repo.findBy({ read: false });\n   */\n  async findBy(queryParams?: QueryParams): Promise<Collection | void> {\n    try {\n      const json = await fetchAPI(this.remotePathOrUrl, queryParams);\n      return humps.camelizeKeys(json) as Collection;\n    } catch (error) {\n      // Don't throw Network Errors. Browsers log these themselves and the realtime connection makes\n      // MagicBell sensitive to connection errors. We don't want to have these flooding consumer logs.\n      if (/Network Error/.test(error.message)) {\n        return;\n      }\n\n      // rethrow so upstream can handle all other errors\n      throw error;\n    }\n  }\n\n  /**\n   * Delete an element by ID from the API server.\n   *\n   * @example\n   * const deleted = await repo.delete('3df592eb-5f09dd6b');\n   */\n  delete(id: string | number): Promise<boolean> {\n    const url = `${this.remotePathOrUrl}/${id}`;\n\n    return deleteAPI(url)\n      .then(() => true)\n      .catch(() => false);\n  }\n}\n","import { postAPI } from '../../lib/ajax';\nimport INotificationRepository from '../../types/INotificationRepository';\nimport { QueryParams } from '../../types/INotificationsStoresCollection';\nimport INotificationStore from '../../types/INotificationStore';\nimport IRemoteNotification from '../../types/IRemoteNotification';\nimport RemoteRepository from '../repository/RemoteRepository';\n\ninterface IWrappedNotification {\n  notification: IRemoteNotification;\n}\n\n/**\n * Class to interact with the notification API endpoints.\n *\n * @example\n * const repo = new NotificationRepository();\n * const notifications = repo.findBy({ unseen: true });\n */\nexport default class NotificationRepository\n  extends RemoteRepository<IWrappedNotification, INotificationStore>\n  implements INotificationRepository\n{\n  constructor(remotePathOrUrl = '/notifications') {\n    super(remotePathOrUrl);\n  }\n\n  archive(id: string): Promise<boolean> {\n    const url = `${this.remotePathOrUrl}/${id}/archive`;\n\n    return postAPI(url)\n      .then(() => true)\n      .catch(() => false);\n  }\n\n  unarchive(id: string): Promise<boolean> {\n    const url = `${this.remotePathOrUrl}/${id}/unarchive`;\n\n    return postAPI(url)\n      .then(() => true)\n      .catch(() => false);\n  }\n\n  markAsRead(id: string): Promise<boolean> {\n    const url = `${this.remotePathOrUrl}/${id}/read`;\n\n    return postAPI(url)\n      .then(() => true)\n      .catch(() => false);\n  }\n\n  markAsUnread(id: string): Promise<boolean> {\n    const url = `${this.remotePathOrUrl}/${id}/unread`;\n\n    return postAPI(url)\n      .then(() => true)\n      .catch(() => false);\n  }\n\n  markAllAsSeen(params?: Omit<QueryParams, 'page' | 'per_page'>) {\n    const url = `${this.remotePathOrUrl}/seen`;\n    return postAPI(url, undefined, params)\n      .then(() => true)\n      .catch(() => false);\n  }\n\n  markAllAsRead(params?: Omit<QueryParams, 'page' | 'per_page'>) {\n    const url = `${this.remotePathOrUrl}/read`;\n    return postAPI(url, undefined, params)\n      .then(() => true)\n      .catch(() => false);\n  }\n}\n","import mitt from 'mitt';\n\nimport clientSettings from '../stores/clientSettings';\nimport NotificationRepository from '../stores/notifications/NotificationRepository';\n\nexport function getAuthHeaders() {\n  const { apiKey, userEmail, userExternalId, userKey } = clientSettings.getState();\n\n  const headers = {\n    'x-magicbell-api-key': apiKey,\n    'x-magicbell-client-user-agent': `${__PACKAGE_NAME__}/${__PACKAGE_VERSION__}`,\n  };\n\n  if (userEmail) headers['x-magicbell-user-email'] = userEmail;\n  if (userKey) headers['x-magicbell-user-hmac'] = userKey;\n  if (userExternalId) headers['x-magicbell-user-external-id'] = userExternalId;\n\n  return headers;\n}\n\n// Note that we have two event emitters. An internal emitter which is used to\n// keep the store in sync with remote events. For example to mark a notification\n// as read when the user reads it in a different tab. And a public emitter, which\n// is not used by our code, but can be used by consumers such as the embeddable.\n// Technically, a single emitter could serve both goals, but that would involve\n// publishing a breaking change.\n\n// The internal emitter that used to keep the store in sync with remote\n/** @deprecated */\nexport const pushEventAggregator = mitt();\n\n// A public emitter, that's not used by our internal code, but can be used by\n// consumers, such as the embeddable.\nexport const eventAggregator = mitt();\n\nexport type EventSource = 'local' | 'remote';\n\n/**\n * Publish events to the internal and public event emitter, based on the event source.\n *\n * @param event The name of the event.\n * @param data The data object to pass along with the event.\n * @param source The origin of the event, local for an action that's triggered by the user in the current tab, remote if it's an event from another instance that should be mirrored.\n */\nexport function emitEvent(event: string, data: unknown, source: EventSource) {\n  if (source === 'remote') {\n    // Only to maintain backwards compatibility.\n    pushEventAggregator.emit(event, data);\n  }\n\n  // wrap the argument in an object, as mitt is limited to a single argument,\n  // and we don't want to change the interface of `data`.\n  eventAggregator.emit(event, { data, source });\n}\n\n/**\n * Publish an ably event to the push event emitter. If the push event contains\n * the ID of a notification, this is fetched before emitting the event.\n *\n * @param event The realtime event\n */\nexport function handleAblyEvent(event: { name: string; data: Record<string, unknown> }) {\n  const { clientId } = clientSettings.getState();\n  const eventName = event.name.replace(/\\//gi, '.');\n  const eventData = event.data;\n  const isLoopbackEvent = eventData.client_id && eventData.client_id === clientId;\n\n  if (isLoopbackEvent) return Promise.resolve(false);\n\n  if (typeof eventData.id === 'string') {\n    if (eventName === 'notifications.delete') {\n      emitEvent(eventName, eventData, 'remote');\n      return Promise.resolve(true);\n    } else {\n      const repository = new NotificationRepository();\n      return repository.get(eventData.id).then((data) => {\n        emitEvent(eventName, data.notification, 'remote');\n        return true;\n      });\n    }\n  }\n\n  emitEvent(eventName, eventData, 'remote');\n  return Promise.resolve(true);\n}\n","import INotificationStore from '../../../types/INotificationStore';\n\nconst emptyStore = {\n  // the context defaults to unarchived notifications, as that's the behaviour\n  // defined in the backend, it's needed here as wel for multi store sync.\n  context: {},\n  total: 0,\n  totalPages: 0,\n  perPage: 0,\n  currentPage: 1,\n  unreadCount: 0,\n  unseenCount: 0,\n  notifications: [],\n};\n\n/**\n * Factory of notifications stores.\n *\n * @param props Properties to initialize the store with\n * @param strategy Function to compare notifications with the context\n * @returns An empty store of notifications\n */\nexport default function buildStore(props: Record<string, unknown>): INotificationStore {\n  return { ...emptyStore, ...props };\n}\n","import { uniqBy } from 'ramda';\n\nimport INotificationStore from '../../../types/INotificationStore';\n\ntype Props = Omit<INotificationStore, 'context'>;\ntype Options = {\n  reset: boolean;\n  prepend: boolean;\n};\n\n/**\n * Function to set props on a notification store. The notifications are merged\n * unless `options.reset` is true.\n *\n * @param store Notifications store\n * @param props Props to set to the store\n * @param options.reset Do not prepend notifications to the store\n * @returns Store\n */\nexport default function setStoreProps(\n  store: INotificationStore,\n  props: Props,\n  options: Partial<Options> = { reset: false },\n): INotificationStore {\n  const { notifications = [], ...meta } = props;\n\n  const allNotifications = options.reset\n    ? notifications\n    : uniqBy(\n        (notification) => notification.id,\n        options.prepend ? [...notifications, ...store.notifications] : [...store.notifications, ...notifications],\n      );\n\n  return { context: store.context, notifications: allNotifications, ...meta };\n}\n","import { isNil } from 'ramda';\n\nimport { IRemoteNotification } from '../../../types';\nimport { IStrategyComparator } from '../../../types/INotificationStore';\n\nfunction eq(value, other) {\n  return value === other || (value !== value && other !== other);\n}\n\nfunction ensureArray(value) {\n  return Array.isArray(value) ? value : String(value).split(',');\n}\n\nexport type NotificationCompareStrategy = (\n  notification: IRemoteNotification,\n  context: Record<string, unknown>,\n  comparator?: IStrategyComparator,\n) => { result: boolean; delta: string[] };\n\n/**\n * Check if a notification satisfies all conditions of the given `context`. It\n * Uses equal to compare.\n *\n * @param notification Notification to test\n * @param context Set of rules to test the notification against\n * @param comparator Function used to compare notification attributes and context values\n */\nexport function objMatchesContext(\n  notification: IRemoteNotification,\n  context: Record<string, unknown>,\n  comparator: IStrategyComparator = eq,\n) {\n  const diff: string[] = [];\n\n  // backend defaults to unarchived notifications, so we need to do the same\n  context = { archived: false, ...context };\n  Object.keys(context).forEach((attr) => {\n    const condition = context[attr];\n\n    if (\n      (attr === 'read' && !comparator(!isNil(notification.readAt), condition)) ||\n      (attr === 'seen' && !comparator(!isNil(notification.seenAt), condition)) ||\n      (attr === 'archived' && !comparator(!isNil(notification.archivedAt), condition)) ||\n      (attr === 'categories' &&\n        ensureArray(condition).every((category) => !comparator(notification.category, category))) ||\n      (attr === 'topics' && ensureArray(condition).every((topic) => !comparator(notification.topic, topic))) ||\n      (Object.hasOwnProperty.call(notification, attr) && !comparator(notification[attr], condition))\n    ) {\n      diff.push(attr);\n    }\n  });\n\n  return { result: diff.length === 0, delta: diff };\n}\n","import produce from 'immer';\nimport { findIndex, mergeRight, propEq } from 'ramda';\nimport create from 'zustand';\n\nimport { emitEvent } from '../../lib/realtime';\nimport { INotificationsStoresCollection, INotificationStore, IRemoteNotification } from '../../types';\nimport buildStore from './helpers/buildStore';\nimport setStoreProps from './helpers/setStoreProps';\nimport { objMatchesContext } from './helpers/strategies';\nimport NotificationRepository from './NotificationRepository';\n\nfunction unix() {\n  return Math.floor(Date.now() / 1000);\n}\n\n/**\n * Collection of notifications store. It contains all stores of notifications\n * and exposes methods to interact with them.\n *\n * @private Use the `useNotifications` hook instead.\n */\nconst useNotificationStoresCollection = create<INotificationsStoresCollection>((set, get) => ({\n  stores: {},\n  _repository: new NotificationRepository(),\n\n  setStore: (storeId, defaultQueryParams = {}, otherProps: Partial<INotificationStore> = {}) => {\n    set(\n      produce<INotificationsStoresCollection>((draft) => {\n        draft.stores[storeId] = buildStore({ ...otherProps, context: defaultQueryParams });\n      }),\n    );\n  },\n\n  fetchStore: async (storeId, queryParams = {}, options = {}) => {\n    const { stores, _repository } = get();\n    const store = stores[storeId];\n\n    if (store) {\n      const response = await _repository.findBy({ ...store.context, ...queryParams });\n      if (!response) return;\n\n      set(\n        produce<INotificationsStoresCollection>((draft) => {\n          draft.stores[storeId] = setStoreProps(store, { ...response, lastFetchedAt: new Date() }, options);\n        }),\n      );\n    } else {\n      // Provided for development support.\n      // eslint-disable-next-line no-console\n      console.error(`Store not found. Define a store with the ${storeId} ID`);\n    }\n  },\n\n  fetchAllStores: async (queryParams = {}, options = {}) => {\n    const { stores, fetchStore } = get();\n\n    const storeIds = Object.keys(stores);\n    const fetchers = storeIds.map((storeId) => fetchStore(storeId, queryParams, options));\n    await Promise.all(fetchers);\n  },\n\n  markNotificationAsSeen: (notification: IRemoteNotification) => {\n    const { stores } = get();\n    const notificationId = notification.id;\n    emitEvent('notifications.seen', notification, 'local');\n\n    set(\n      produce<INotificationsStoresCollection>((draft) => {\n        for (const storeId in stores) {\n          const { notifications, unseenCount } = stores[storeId];\n          const index = findIndex(propEq('id', notificationId), notifications);\n\n          if (index > -1) {\n            const notification = notifications[index];\n\n            if (!notification.seenAt) {\n              draft.stores[storeId].unseenCount = Math.max(0, unseenCount - 1);\n              draft.stores[storeId].notifications[index] = mergeRight(notifications[index], {\n                seenAt: unix(),\n              });\n            }\n          }\n        }\n      }),\n    );\n  },\n\n  markNotificationAsRead: (notification: IRemoteNotification) => {\n    const { stores, _repository } = get();\n    const { id: notificationId } = notification;\n    const promise = _repository.markAsRead(notificationId);\n    emitEvent('notifications.read', notification, 'local');\n\n    set(\n      produce<INotificationsStoresCollection>((draft) => {\n        const now = unix();\n        const attrs = { readAt: now, seenAt: now };\n\n        for (const storeId in stores) {\n          const { total, notifications, context, unreadCount, unseenCount } = stores[storeId];\n          const index = findIndex(propEq('id', notificationId), notifications);\n\n          if (index > -1) {\n            // Decrease the counters if the notification wasn't already read|seen, and clamp to zero as it might happen\n            // that markAsSeen has set the counter to zero, while the notification.seenAt is still undefined\n            if (!notification.readAt) draft.stores[storeId].unreadCount = Math.max(0, unreadCount - 1);\n            if (!notification.seenAt) draft.stores[storeId].unseenCount = Math.max(0, unseenCount - 1);\n\n            const readNotification = mergeRight(notifications[index], attrs);\n            if (objMatchesContext(readNotification, context).result) {\n              // Update the store\n              draft.stores[storeId].notifications[index] = readNotification;\n            } else {\n              // Remove notification from the store\n              draft.stores[storeId].total = Math.max(0, total - 1);\n              draft.stores[storeId].notifications.splice(index, 1);\n            }\n          } else {\n            const readNotification = mergeRight(notification, attrs);\n            if (objMatchesContext(readNotification, context).result) {\n              // Add the notification to the store\n              draft.stores[storeId].total += 1;\n              draft.stores[storeId].notifications.push(readNotification);\n            }\n          }\n        }\n      }),\n    );\n\n    return promise;\n  },\n\n  markNotificationAsUnread: (notification: IRemoteNotification) => {\n    const { stores, _repository } = get();\n    const { id: notificationId } = notification;\n    const promise = _repository.markAsUnread(notificationId);\n    emitEvent('notifications.unread', notification, 'local');\n\n    set(\n      produce<INotificationsStoresCollection>((draft) => {\n        const attrs = { readAt: null };\n\n        for (const storeId in stores) {\n          const { notifications, context } = stores[storeId];\n          const index = findIndex(propEq('id', notificationId), notifications);\n\n          if (index > -1) {\n            const unreadNotification = mergeRight(notifications[index], attrs);\n            if (objMatchesContext(unreadNotification, context).result) {\n              // Update the store\n              if (notification.readAt) draft.stores[storeId].unreadCount += 1;\n              draft.stores[storeId].notifications[index] = unreadNotification;\n            } else {\n              // Remove notification from the store\n              draft.stores[storeId].total = Math.max(0, draft.stores[storeId].total - 1);\n              draft.stores[storeId].notifications.splice(index, 1);\n            }\n          } else {\n            const unreadNotification = mergeRight(notification, attrs);\n            if (objMatchesContext(unreadNotification, context).result) {\n              // Add the notification to the store\n              draft.stores[storeId].total += 1;\n              if (notification.readAt) draft.stores[storeId].unreadCount += 1;\n              draft.stores[storeId].notifications.push(unreadNotification);\n            }\n          }\n        }\n      }),\n    );\n\n    return promise;\n  },\n\n  archiveNotification: (notification, options = {}) => {\n    const { stores, _repository } = get();\n    const { id: notificationId } = notification;\n\n    let promise = Promise.resolve(true);\n\n    // Do not persist the state if this op is a consequence of a remote event.\n    if (options.persist !== false) {\n      promise = _repository.archive(notificationId);\n      emitEvent('notifications.archived', notification, 'local');\n    }\n\n    set(\n      produce<INotificationsStoresCollection>((draft) => {\n        const now = unix();\n        const attrs = { archivedAt: now };\n\n        for (const storeId in stores) {\n          const store = stores[storeId];\n          const index = findIndex(propEq('id', notificationId), store.notifications);\n\n          if (index > -1) {\n            const newNotification = { ...store.notifications[index], ...attrs };\n            if (objMatchesContext(newNotification, store.context).result) {\n              // Update the store\n              draft.stores[storeId].notifications[index] = newNotification;\n            } else {\n              // Decrease the counters if the notification was included in it, and clamp to zero\n              if (!notification.readAt) draft.stores[storeId].unreadCount = Math.max(0, store.unreadCount - 1);\n              if (!notification.seenAt) draft.stores[storeId].unseenCount = Math.max(0, store.unseenCount - 1);\n\n              // Remove notification from the store\n              draft.stores[storeId].total = Math.max(0, store.total - 1);\n              draft.stores[storeId].notifications.splice(index, 1);\n            }\n          } else {\n            const newNotification = { ...notification, ...attrs };\n            if (objMatchesContext(newNotification, store.context).result) {\n              // Add the notification to the store\n              if (!notification.readAt) draft.stores[storeId].unreadCount += 1;\n              if (!notification.seenAt) draft.stores[storeId].unseenCount += 1;\n\n              draft.stores[storeId].total += 1;\n              draft.stores[storeId].notifications.push(newNotification);\n            }\n          }\n        }\n      }),\n    );\n\n    return promise;\n  },\n\n  unarchiveNotification: (notification, options = {}) => {\n    const { stores, _repository } = get();\n    const { id: notificationId } = notification;\n    let promise = Promise.resolve(true);\n\n    // Do not persist the state if this op is a consequence of a remote event.\n    if (options.persist !== false) {\n      promise = _repository.unarchive(notificationId);\n      emitEvent('notifications.unarchived', notification, 'local');\n    }\n\n    set(\n      produce<INotificationsStoresCollection>((draft) => {\n        const attrs = { archivedAt: null };\n\n        for (const storeId in stores) {\n          const store = stores[storeId];\n          const index = findIndex(propEq('id', notificationId), store.notifications);\n\n          if (index > -1) {\n            const newNotification = { ...store.notifications[index], ...attrs };\n            if (objMatchesContext(newNotification, store.context).result) {\n              draft.stores[storeId].notifications[index] = newNotification;\n            } else {\n              // Remove notification from the store\n              if (!notification.readAt) draft.stores[storeId].unreadCount = Math.max(0, store.unreadCount - 1);\n              if (!notification.seenAt) draft.stores[storeId].unseenCount = Math.max(0, store.unseenCount - 1);\n\n              draft.stores[storeId].total = Math.max(0, store.total - 1);\n              draft.stores[storeId].notifications.splice(index, 1);\n            }\n          } else {\n            const newNotification = { ...notification, ...attrs };\n            if (objMatchesContext(newNotification, store.context).result) {\n              // Add the notification to the store\n              if (!notification.readAt) draft.stores[storeId].unreadCount += 1;\n              if (!notification.seenAt) draft.stores[storeId].unseenCount += 1;\n\n              draft.stores[storeId].total += 1;\n              draft.stores[storeId].notifications.push(newNotification);\n            }\n          }\n        }\n      }),\n    );\n\n    return promise;\n  },\n\n  deleteNotification: (notification: IRemoteNotification, options = {}) => {\n    const { stores, _repository } = get();\n    const notificationId = notification.id;\n    let promise = Promise.resolve(true);\n\n    // Do not persist the state is this op is a consequence of a remote event.\n    // Neither emit a local event.\n    if (options.persist !== false) {\n      promise = _repository.delete(notificationId);\n      emitEvent('notifications.delete', notification, 'local');\n    }\n\n    set(\n      produce<INotificationsStoresCollection>((draft) => {\n        for (const storeId in stores) {\n          const { notifications, total, unseenCount, unreadCount } = stores[storeId];\n          const index = findIndex(propEq('id', notificationId), notifications);\n\n          if (index > -1) {\n            const notification = notifications[index];\n\n            if (!notification.seenAt) draft.stores[storeId].unseenCount = Math.max(0, unseenCount - 1);\n            if (!notification.readAt) draft.stores[storeId].unreadCount = Math.max(0, unreadCount - 1);\n\n            draft.stores[storeId].total = Math.max(0, total - 1);\n            draft.stores[storeId].notifications.splice(index, 1);\n          }\n        }\n      }),\n    );\n\n    return promise;\n  },\n\n  markAllAsSeen: (options = { persist: true, updateModels: true }) => {\n    const { stores, _repository } = get();\n    let promise = Promise.resolve(true);\n\n    // Do not persist the state if this op is a consequence of a remote event.\n    // Neither emit a local event.\n    if (options.persist !== false) {\n      const params = options.storeId ? stores[options.storeId]?.context : {};\n      promise = _repository.markAllAsSeen(params);\n      emitEvent('notifications.seen.all', null, 'local');\n    }\n\n    set(\n      produce<INotificationsStoresCollection>((draft) => {\n        const changedNotifications = new Map();\n        const now = unix();\n\n        for (const storeId in stores) {\n          const { context } = stores[storeId];\n\n          draft.stores[storeId].unseenCount = 0;\n\n          if (options.updateModels === false) continue;\n\n          // don't iterate over notifications in stores that only hold seen notifications\n          if (context.seen !== true) {\n            for (const notification of draft.stores[storeId].notifications) {\n              // don't change notifications that are already seen\n              if (notification.seenAt) continue;\n\n              notification.seenAt = now;\n              changedNotifications.set(notification.id, notification);\n            }\n          }\n\n          // stores that don't include seen notifications, can be flushed\n          if (context.seen === false) {\n            draft.stores[storeId].notifications = [];\n            draft.stores[storeId].total = 0;\n          }\n        }\n\n        // do a second pass to update the notifications in the stores that don't hold seen notifications\n        for (const storeId in stores) {\n          const { context } = stores[storeId];\n          // skip stores that already hold seen notifications\n          if (context.seen !== true) continue;\n\n          const notifications = draft.stores[storeId].notifications;\n          for (const notification of changedNotifications.values()) {\n            if (\n              objMatchesContext(notification, context).result &&\n              !notifications.find((n) => n.id === notification.id)\n            ) {\n              notifications.push(notification);\n              draft.stores[storeId].total += 1;\n            }\n          }\n        }\n      }),\n    );\n\n    return promise;\n  },\n\n  markAllAsRead: (options = { persist: true, updateModels: true }) => {\n    const { stores, _repository } = get();\n    let promise = Promise.resolve(true);\n\n    // Do not persist the state if this op is a consequence of a remote event.\n    // Neither emit a local event.\n    if (options.persist !== false) {\n      const params = options.storeId ? stores[options.storeId]?.context : {};\n      promise = _repository.markAllAsRead(params);\n      emitEvent('notifications.read.all', null, 'local');\n    }\n\n    set(\n      produce<INotificationsStoresCollection>((draft) => {\n        const changedNotifications = new Map();\n        const now = unix();\n\n        for (const storeId in stores) {\n          const { context } = stores[storeId];\n\n          draft.stores[storeId].unreadCount = 0;\n          draft.stores[storeId].unseenCount = 0;\n\n          if (options.updateModels === false) continue;\n\n          // don't iterate over notifications in stores that only hold read notifications\n          if (context.read !== true) {\n            for (const notification of draft.stores[storeId].notifications) {\n              // don't change notifications that are already read\n              if (notification.readAt) continue;\n\n              notification.readAt = now;\n              notification.seenAt = now;\n              changedNotifications.set(notification.id, notification);\n            }\n          }\n\n          // stores that don't include read notifications, can be flushed\n          if (context.read === false) {\n            draft.stores[storeId].notifications = [];\n            draft.stores[storeId].total = 0;\n          }\n        }\n\n        // do a second run to add changed notifications to stores that didn't hold unread notifications\n        for (const storeId in stores) {\n          const { context } = stores[storeId];\n\n          // skip stores that already contain the notification\n          if (context.read !== true) continue;\n\n          const notifications = draft.stores[storeId].notifications;\n          for (const notification of changedNotifications.values()) {\n            if (\n              objMatchesContext(notification, context).result &&\n              !notifications.find((n) => n.id === notification.id)\n            ) {\n              notifications.push(notification);\n              draft.stores[storeId].total += 1;\n            }\n          }\n        }\n      }),\n    );\n\n    return promise;\n  },\n}));\n\nexport default useNotificationStoresCollection;\n","import { useEffect } from 'react';\n\nimport { eventAggregator, EventSource } from '../lib/realtime';\n\ninterface HookOptions {\n  source: EventSource | 'any';\n}\n\n/**\n * React hook to listen to events.\n *\n * @param event Name of the event\n * @param handler Callback function\n * @param options\n */\nexport default function useMagicBellEvent(\n  event: string,\n  handler: (data?: unknown, source?: EventSource) => void,\n  options: HookOptions = { source: 'any' },\n) {\n  useEffect(() => {\n    const callback = (args: Partial<{ data: unknown; source: EventSource }> = {}) => {\n      if (options.source === 'remote' && args.source !== 'remote') return;\n      if (options.source === 'local' && args.source !== 'local') return;\n      handler(args.data, args.source);\n    };\n\n    eventAggregator.on(event, callback);\n\n    return () => {\n      eventAggregator.off(event, callback);\n    };\n    // TODO: Update code to follow lint suggestions of add missing dependencies,\n    // remove [] or wrap parent component in callback\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n}\n","import { useEffect } from 'react';\n\nimport useMagicBellEvent from '../hooks/useMagicBellEvent';\nimport { handleAblyEvent } from '../lib/realtime';\nimport clientSettings from '../stores/clientSettings';\nimport { useNotificationStoresCollection } from '../stores/notifications';\nimport IRemoteNotification from '../types/IRemoteNotification';\n\n/**\n * Component that setups a listener to realtime events and keeps notifications\n * stores up to date.\n *\n * @example <RealtimeListener />\n */\nexport default function RealtimeListener() {\n  const collection = useNotificationStoresCollection();\n  const settings = clientSettings.getState();\n  const client = settings.getClient();\n  const apiKey = settings.apiKey;\n  const user = settings.userExternalId || settings.userEmail;\n\n  const fetchAndResetAll = () => collection.fetchAllStores({ page: 1 }, { reset: true });\n  const fetchAndPrependAll = () => collection.fetchAllStores({ page: 1 }, { prepend: true });\n  const markAllAsSeen = () => collection.markAllAsSeen({ persist: false });\n  const markAllAsRead = () => collection.markAllAsRead({ persist: false });\n  const removeNotification = (data: IRemoteNotification) => collection.deleteNotification(data, { persist: false });\n  const archiveNotification = (data: IRemoteNotification) => collection.archiveNotification(data, { persist: false });\n  const unarchiveNotification = (data: IRemoteNotification) =>\n    collection.unarchiveNotification(data, { persist: false });\n\n  useEffect(() => {\n    if (!apiKey || !user) return;\n    const listen = client.listen();\n\n    listen.forEach((event) => {\n      if (!event) return;\n      void handleAblyEvent(event);\n    });\n\n    return () => listen.close();\n  }, [client, apiKey, user]);\n\n  useMagicBellEvent('reconnected', fetchAndResetAll);\n  useMagicBellEvent('notifications.new', fetchAndPrependAll, { source: 'remote' });\n  useMagicBellEvent('notifications.seen.all', markAllAsSeen, { source: 'remote' });\n  useMagicBellEvent('notifications.read.all', markAllAsRead, { source: 'remote' });\n  useMagicBellEvent('notifications.read', fetchAndResetAll, { source: 'remote' });\n  useMagicBellEvent('notifications.unread', fetchAndResetAll, { source: 'remote' });\n  useMagicBellEvent('notifications.delete', removeNotification, { source: 'remote' });\n  useMagicBellEvent('notifications.archived', archiveNotification, { source: 'remote' });\n  useMagicBellEvent('notifications.unarchived', unarchiveNotification, { source: 'remote' });\n  return null;\n}\n","import React, { useEffect, useState } from 'react';\n\nimport clientSettings, { ClientSettings } from '../../stores/clientSettings';\nimport useConfig from '../../stores/config';\nimport { useNotificationStoresCollection } from '../../stores/notifications';\nimport buildStore from '../../stores/notifications/helpers/buildStore';\nimport { QueryParams } from '../../types/INotificationsStoresCollection';\nimport INotificationStore from '../../types/INotificationStore';\nimport RealtimeListener from '../RealtimeListener';\n\ntype StoreConfig = {\n  id: string;\n  defaultQueryParams: QueryParams;\n  defaults?: Partial<Omit<INotificationStore, 'context'>>;\n};\n\nexport interface MagicBellProviderProps {\n  apiKey: string;\n  userEmail?: string;\n  userExternalId?: string;\n  userKey?: string;\n  children: React.ReactElement | React.ReactElement[];\n  stores?: StoreConfig[];\n  serverURL?: string;\n  disableRealtime?: boolean;\n}\n\nfunction setupXHR({ serverURL, ...userSettings }: Omit<MagicBellProviderProps, 'children' | 'stores'>) {\n  const settings = userSettings as ClientSettings;\n  if (serverURL) settings.serverURL = serverURL;\n  clientSettings.setState(settings);\n\n  return settings;\n}\n\nfunction setupStores(storesConfig: StoreConfig[]) {\n  const stores = {};\n\n  storesConfig.forEach((store) => {\n    const { defaultQueryParams: context, defaults = {} } = store;\n    stores[store.id] = buildStore({ context, ...defaults });\n  });\n\n  useNotificationStoresCollection.setState({ stores });\n\n  return stores;\n}\n\n/**\n * Provider component for Magicbell.\n *\n * @param props\n * @param props.apiKey API key of the MagicBell project\n * @param props.userEmail Email of the user whose notifications will be displayed\n * @param props.userExternalId External ID of the user whose notifications will be displayed\n * @param props.userKey Computed HMAC of the user whose notifications will be displayed, compute this with the secret of the magicbell project\n * @param props.stores List of stores to be created\n * @param props.disableRealtime Disable realtime updates\n *\n * @example\n * ```javascript\n * <MagicBellProvider apiKey={MAGICBELL_API_KEY} userEmail={email}>\n *   <App />\n * </MagicBellProvider>\n * ```\n */\nexport default function MagicBellProvider({\n  children,\n  stores = [{ id: 'default', defaultQueryParams: {} }],\n  disableRealtime,\n  ...clientSettings\n}: MagicBellProviderProps) {\n  useState(() => setupXHR(clientSettings));\n  useEffect(() => {\n    setupStores(stores);\n  }, []);\n\n  const config = useConfig();\n\n  useEffect(() => {\n    if (!config.lastFetchedAt) config.fetch();\n  }, [config]);\n\n  return (\n    <>\n      {disableRealtime ? null : <RealtimeListener />}\n      {children}\n    </>\n  );\n}\n","import { path } from 'ramda';\n\nimport { IRemoteConfig } from '../types';\nimport { postAPI } from './ajax';\n\nfunction stringToUint8Array(plainString: string) {\n  const padding = '='.repeat((4 - (plainString.length % 4)) % 4);\n  const base64 = (plainString + padding).replace(/-/g, '+').replace(/_/g, '/');\n\n  const rawData = window.atob(base64);\n  const outputArray = new Uint8Array(rawData.length);\n\n  for (let i = 0; i < rawData.length; ++i) {\n    outputArray[i] = rawData.charCodeAt(i);\n  }\n\n  return outputArray;\n}\n\n/**\n * Store a subscription in the backend so we can notify this user later.\n *\n * @param subscription The push subscription\n */\nfunction storeSubscription(subscription) {\n  const data = {\n    web_push_subscription: {\n      data: subscription,\n    },\n  };\n\n  return postAPI('/web_push_subscriptions', data);\n}\n\n/**\n * Request permission to send push notifications.\n *\n * @param pushManager\n * @param publicKey VAPID public key\n */\nexport function subscribeToPushNotifications(pushManager: PushManager, publicKey: string) {\n  const applicationServerKey = stringToUint8Array(publicKey);\n  return pushManager.subscribe({ userVisibleOnly: true, applicationServerKey });\n}\n\n/**\n * Request permission to send push notifications and store the subscription in\n * the backend.\n *\n * @param pushManager\n * @param user\n * @param project\n */\nexport async function createPushSubscription(pushManager: PushManager, config: IRemoteConfig) {\n  const vapidPublicKey = path(['webPush', 'config', 'vapidAuthentication', 'publicKey'], config.channels) as string;\n  const subscription = await subscribeToPushNotifications(pushManager, vapidPublicKey);\n\n  return storeSubscription(subscription.toJSON());\n}\n\n/**\n * Request permission to send push notifications in Safari and store the\n * subscription in the backend.\n *\n * @param authenticationToken A string that helps you identify the user\n * @param webServiceUrl URL of the Safari web push service\n * @param websitePushID Apple identifier of the website push service\n */\nexport function createSafariPushSubscription(\n  authenticationToken: string,\n  webServiceUrl: string,\n  websitePushID = 'web.com.magicbell-notifications',\n) {\n  const permissionData = window['safari'].pushNotification.permission(websitePushID);\n  if (permissionData.permission === 'granted') return Promise.resolve(permissionData);\n  if (permissionData.permission === 'denied') return Promise.reject(false);\n\n  return new Promise(function (resolve, reject) {\n    window['safari'].pushNotification.requestPermission(\n      webServiceUrl,\n      websitePushID,\n      { authenticationToken },\n      function (permissionData) {\n        if (permissionData.deviceToken) {\n          const subscriptionData = {\n            endpoint: permissionData.deviceToken,\n            keys: { websitePushID },\n            platform: 'safari',\n          };\n\n          storeSubscription(subscriptionData)\n            .then((subscription) => {\n              resolve(subscription);\n            })\n            .catch((error) => {\n              reject(error);\n            });\n        } else {\n          const error = new Error('Permission was denied');\n          reject(error);\n        }\n      },\n    );\n  });\n}\n","import { path } from 'ramda';\nimport { useEffect } from 'react';\n\nimport { createPushSubscription, createSafariPushSubscription } from '../../lib/push';\nimport useConfig from '../../stores/config';\n\nexport interface Props {\n  children: (params: { createSubscription: () => Promise<unknown>; isPushAPISupported: boolean }) => JSX.Element;\n  serviceWorkerPath?: string;\n  skipServiceWorkerRegistration?: boolean;\n}\n\n/**\n * Headless component to create subscriptions to web push notifications.\n *\n * @example\n * <WebPushNotificationsSubscriber>\n *   {({ createSubscription }) =>\n *     <button onClick={createSubscription}>Subscribe</button>}\n * <WebPushNotificationsSubscriber>\n */\nexport default function WebPushNotificationsSubscriber({\n  children,\n  serviceWorkerPath = '/service-worker.js',\n  skipServiceWorkerRegistration = false,\n}: Props) {\n  const config = useConfig();\n  const isSafari = 'safari' in window;\n  const isPushAPISupported = 'PushManager' in window;\n\n  useEffect(() => {\n    if (!skipServiceWorkerRegistration) {\n      navigator.serviceWorker.register(serviceWorkerPath);\n    }\n  }, [serviceWorkerPath, skipServiceWorkerRegistration]);\n\n  const createSubscription = async () => {\n    if (!config) {\n      return Promise.reject(new Error('Context for MagicBell was not found'));\n    }\n\n    if (isSafari) {\n      const authenticationToken = path(['safari', 'authenticationToken'], config.channels?.webPush.config) as string;\n      const websitePushID = path(['safari', 'websitePushId'], config.channels?.webPush.config) as string;\n      const webServiceUrl = path(['safari', 'webServiceUrl'], config.channels?.webPush.config) as string;\n\n      return createSafariPushSubscription(authenticationToken, webServiceUrl, websitePushID);\n    }\n\n    if (isPushAPISupported) {\n      return navigator.serviceWorker.ready.then(async (registration) => {\n        await createPushSubscription(registration.pushManager, config);\n      });\n    }\n  };\n\n  return children({ createSubscription, isPushAPISupported });\n}\n","import { useCallback, useEffect } from 'react';\n\nimport useConfig from '../stores/config';\nimport { useNotificationStoresCollection } from '../stores/notifications';\nimport { QueryParams } from '../types/INotificationsStoresCollection';\nimport INotificationStore from '../types/INotificationStore';\n\ntype FetchOptions = Partial<{\n  reset: boolean;\n}>;\n\nexport interface NotificationStore extends INotificationStore {\n  isEmpty: boolean;\n  hasNextPage: boolean;\n\n  /**\n   * Fetch notifications from the API server. The pagination data is also\n   * updated. By default the array of notifications is not reset.\n   *\n   * @param queryParams Parameters to send to the API.\n   */\n  fetch: (queryParams?: QueryParams, options?: FetchOptions) => Promise<void>;\n\n  /**\n   * Fetch the next page of notifications from the API server. The notifications\n   * will be appended to the current list of notifications.\n   *\n   * @param queryParams Parameters to send to the API.\n   */\n  fetchNextPage: (queryParams?: Omit<QueryParams, 'page' | 'per_page'>, options?: FetchOptions) => Promise<void>;\n\n  /**\n   * Mark all notifications as seen. Resets the `unseenCount` attribute.\n   *\n   * @param options.persist Mark all notifications as seen in the server\n   * @param options.updateModels Mark all fetched notifications as seen\n   */\n  markAllAsSeen: (options?: Partial<{ persist: boolean; updateModels: boolean }>) => Promise<boolean>;\n\n  /**\n   * Mark all notifications as read. Resets the `unreadCount` attribute.\n   *\n   * @param options.persist Mark all notifications as read in the server\n   * @param options.updateModels Mark all fetched notifications as read\n   */\n  markAllAsRead: (options?: Partial<{ persist: boolean; updateModels: boolean }>) => Promise<boolean>;\n}\n\n/**\n * Hook to get a notifications store from the stores collection. It fetches the\n * first page of the store if it is not fetched already.\n *\n * @param storeId ID of the notifications store (optional)\n *\n * @example\n * const store = useNotifications('mentions');\n */\nexport default function useNotifications(storeId = 'default'): NotificationStore | null {\n  const { stores, fetchStore, markAllAsSeen, markAllAsRead } = useNotificationStoresCollection();\n  const config = useConfig();\n  const store = stores[storeId];\n\n  const fetch = useCallback<NotificationStore['fetch']>(\n    (queryParams, options) => fetchStore(storeId, queryParams, options),\n    [fetchStore, storeId],\n  );\n\n  const fetchNextPage = useCallback<NotificationStore['fetchNextPage']>(\n    (queryParams = {}, options) => {\n      const page = store.currentPage + 1;\n      return fetchStore(storeId, { ...queryParams, page }, options);\n    },\n    [fetchStore, storeId, store?.currentPage],\n  );\n\n  useEffect(() => {\n    if (!store) return;\n    if (config.lastFetchedAt && !store.lastFetchedAt) fetch({ page: 1 });\n  }, [config.lastFetchedAt, store, fetch]);\n\n  const markAllAsReadFn = useCallback<NotificationStore['markAllAsRead']>(\n    (options) => markAllAsRead({ ...options, storeId }),\n    [markAllAsRead, storeId],\n  );\n\n  const markAllAsSeenFn = useCallback<NotificationStore['markAllAsSeen']>(\n    (options) => markAllAsSeen({ ...options, storeId }),\n    [markAllAsSeen, storeId],\n  );\n\n  if (!store) return null;\n\n  return {\n    ...store,\n    isEmpty: store.notifications.length === 0,\n    hasNextPage: store.currentPage < store.totalPages,\n    fetch,\n    fetchNextPage,\n    markAllAsSeen: markAllAsSeenFn,\n    markAllAsRead: markAllAsReadFn,\n  };\n}\n","import useNotifications, { NotificationStore } from './useNotifications';\n\ninterface useBellArgs {\n  storeId?: string;\n}\n\n/**\n * Hook to get a notification store to be used in a bell.\n *\n * The `markAllAsSeen` function exposed by this hook does not update the fetched\n * notifications.\n *\n * @param props\n * @param props.storeId Optional ID of the notifications store\n * @returns A store of notifications (if the store exists)\n *\n * @example\n * const { unreadCount, markAllAsSeen } = useBell();\n */\nexport default function useBell({ storeId }: useBellArgs = {}): NotificationStore | null {\n  const store = useNotifications(storeId);\n\n  const markAllAsSeen = () => {\n    if (store && store.unseenCount > 0) return store?.markAllAsSeen({ updateModels: false });\n    return Promise.resolve(true);\n  };\n\n  if (store) return { ...store, markAllAsSeen };\n  return null;\n}\n","import dayjs, { type Dayjs } from 'dayjs';\nimport localizedFormat from 'dayjs/plugin/localizedFormat';\nimport relativeTime from 'dayjs/plugin/relativeTime';\nimport updateLocale from 'dayjs/plugin/updateLocale';\n\ndayjs.extend(localizedFormat);\ndayjs.extend(relativeTime);\ndayjs.extend(updateLocale);\n\n// Export after the extensions have been registered so types are applied correctly.\nexport type { Dayjs };\n\n/**\n * Function to build a Date given a number of seconds.\n *\n * @example secondsToDate(1582263571)\n */\nexport function secondsToDate(seconds: number | null) {\n  return seconds ? toDate(seconds * 1000) : null;\n}\n\n/**\n * Function to build a Date given a string or number of milliseconds.\n *\n * @example toDate('2020-02-01')\n */\nexport function toDate(date: string | number | Dayjs | Date) {\n  return dayjs(date);\n}\n\n/**\n * Function to return a UNIX timestamp from a date representation. This value is\n * floored to the nearest second.\n *\n * @example toUnix('2020-10-06')\n */\nexport function toUnix(date?: string | number | Dayjs | Date) {\n  return dayjs(date).unix();\n}\n","import { isNil } from 'ramda';\n\n/**\n * Function to parse an object.\n *\n * @param obj\n * @returns\n */\nexport function parseJSON(obj: Record<string, unknown> | string | null) {\n  if (isNil(obj)) return null;\n  if (typeof obj === 'string') {\n    try {\n      return JSON.parse(obj);\n    } catch (e) {\n      // intentionally left blank\n    }\n  }\n\n  return obj;\n}\n","import { isNil } from 'ramda';\n\nimport { secondsToDate } from '../lib/date';\nimport { parseJSON } from '../lib/json';\nimport { useNotificationStoresCollection } from '../stores/notifications';\nimport INotification from '../types/INotification';\nimport IRemoteNotification from '../types/IRemoteNotification';\n\n/**\n * Hook that builds a notification object.\n *\n * @param data Notification data.\n */\nexport default function useNotificationFactory(data: IRemoteNotification): INotification {\n  const {\n    markNotificationAsRead,\n    markNotificationAsSeen,\n    markNotificationAsUnread,\n    deleteNotification,\n    archiveNotification,\n    unarchiveNotification,\n  } = useNotificationStoresCollection();\n\n  const markAsSeen = () => markNotificationAsSeen(data);\n  const markAsRead = () => markNotificationAsRead(data);\n  const markAsUnread = () => markNotificationAsUnread(data);\n  const deleteSelf = () => deleteNotification(data);\n  const archive = () => archiveNotification(data);\n  const unarchive = () => unarchiveNotification(data);\n\n  return {\n    ...data,\n    customAttributes: parseJSON(data.customAttributes),\n    readAt: secondsToDate(data.readAt),\n    seenAt: secondsToDate(data.seenAt),\n    sentAt: secondsToDate(data.sentAt),\n    archivedAt: secondsToDate(data.archivedAt),\n    isSeen: !isNil(data.seenAt),\n    isRead: !isNil(data.readAt),\n    isArchived: !isNil(data.archivedAt),\n    sanitizedContent: data.content,\n    markAsSeen,\n    markAsRead,\n    markAsUnread,\n    delete: deleteSelf,\n    archive,\n    unarchive,\n  };\n}\n","import { useEffect } from 'react';\n\nimport INotification from '../types/INotification';\n\n/**\n * Hook that is ran when the component is unmounted. By default marks a\n * notification as seen.\n *\n * @param notification The notification\n * @param fn Callback function to execute when the component is unmounted\n *\n * @example\n * useNotificationUnmount(notification);\n */\nexport default function useNotificationUnmount(\n  notification: INotification,\n  fn?: (notification: INotification) => void,\n) {\n  useEffect(() => {\n    return () => {\n      if (fn) fn(notification);\n      else notification.markAsSeen();\n    };\n    // TODO: Update code to follow lint suggestions of add missing dependencies,\n    // remove [] or wrap parent component in callback\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n}\n","import INotification from '../types/INotification';\nimport IRemoteNotification from '../types/IRemoteNotification';\nimport useNotificationFactory from './useNotificationFactory';\nimport useNotificationUnmount from './useNotificationUnmount';\n\nexport default function useNotification(\n  data: IRemoteNotification,\n  onUnmount?: (notification: INotification) => void,\n): INotification {\n  const notification = useNotificationFactory(data);\n  useNotificationUnmount(notification, onUnmount);\n\n  return notification;\n}\n","import humps from 'humps';\n\nimport { fetchAPI, putAPI } from '../../lib/ajax';\nimport IRemoteNotificationPreferences from '../../types/IRemoteNotificationPreferences';\n\ninterface IWrappedNotificationPreferences {\n  notificationPreferences: IRemoteNotificationPreferences;\n}\n\n/**\n * Class to interact with the notification preferences API endpoints.\n *\n * @example\n * const repo = new NotificationPreferencesRepository();\n * const preferences = repo.get();\n */\nexport default class NotificationPreferencesRepository {\n  remotePathOrUrl: string;\n\n  constructor(remotePathOrUrl = '/notification_preferences') {\n    this.remotePathOrUrl = remotePathOrUrl;\n  }\n\n  /**\n   * Get the user preferences from the API server. Object properties will be camelized.\n   * Wrapping of message to server is handled for us (Design Principle: The Principle of Least\n   * Knowledge).\n   */\n  async get(): Promise<IWrappedNotificationPreferences> {\n    const url = this.remotePathOrUrl;\n    const json = await fetchAPI(url);\n\n    return humps.camelizeKeys(json) as IWrappedNotificationPreferences;\n  }\n\n  /**\n   * Update user preferences in the API server. Object properties will be decamelized before\n   * being send to the server.\n   *\n   * @param data Preferences to send to the server.\n   */\n  async update(data: IRemoteNotificationPreferences): Promise<IWrappedNotificationPreferences> {\n    const url = this.remotePathOrUrl;\n    const payload = humps.decamelizeKeys({ notificationPreferences: data }) as Record<string, unknown>;\n    const json = await putAPI(url, payload);\n\n    return humps.camelizeKeys(json) as IWrappedNotificationPreferences;\n  }\n}\n","import create from 'zustand';\n\nimport IRemoteNotificationPreferences from '../../types/IRemoteNotificationPreferences';\nimport NotificationPreferencesRepository from './NotificationPreferencesRepository';\n\nexport interface INotificationPreferences extends IRemoteNotificationPreferences {\n  lastFetchedAt?: number;\n\n  /**\n   * Fetch the notification preferences for the current user from the MagicBell server.\n   */\n  fetch: () => Promise<void>;\n\n  /**\n   * Update the notification preferences for the current user.\n   *\n   * @preferences Object containing the new preferences.\n   */\n  save: (preferences: IRemoteNotificationPreferences) => Promise<void>;\n\n  _repository: NotificationPreferencesRepository;\n}\n\n/**\n * Remote notification preferences store. It contains all preferences stored in MagicBell servers for this user.\n *\n * @example\n * const { fetch } = useNotificationPreferences();\n * useEffect(() => fetch(), []);\n */\nconst useNotificationPreferences = create<INotificationPreferences>((set, get) => ({\n  categories: [],\n\n  _repository: new NotificationPreferencesRepository(),\n\n  fetch: async () => {\n    const { _repository } = get();\n\n    try {\n      const { notificationPreferences: json } = await _repository.get();\n      set({ ...json, lastFetchedAt: Date.now() });\n    } catch (error) {\n      set({ categories: [], lastFetchedAt: Date.now() });\n    }\n  },\n\n  save: async (preferences) => {\n    const { _repository } = get();\n\n    try {\n      const { notificationPreferences: json } = await _repository.update(preferences);\n      set({ ...json, lastFetchedAt: Date.now() });\n    } catch (error) {\n      set({ categories: [], lastFetchedAt: Date.now() });\n    }\n  },\n}));\n\nexport default useNotificationPreferences;\n"],"names":["clientSettings","create","set","get","_client","_key","state","key","UserClient","clientSettings$1","sendAPIRequest","method","path","data","params","client","stringParams","value","fetchAPI","url","postAPI","deleteAPI","putAPI","ConfigRepository","remotePathOrUrl","__publicField","json","humps","useConfig","_repository","__spreadProps","__spreadValues","useConfig$1","RemoteRepository","id","queryParams","error","NotificationRepository","pushEventAggregator","mitt","eventAggregator","emitEvent","event","source","handleAblyEvent","clientId","eventName","eventData","emptyStore","buildStore","props","setStoreProps","store","options","_a","notifications","meta","__objRest","allNotifications","uniqBy","notification","eq","other","ensureArray","objMatchesContext","context","comparator","diff","attr","condition","isNil","category","topic","unix","useNotificationStoresCollection","storeId","defaultQueryParams","otherProps","produce","draft","stores","response","fetchStore","fetchers","notificationId","unseenCount","index","findIndex","propEq","mergeRight","promise","now","attrs","total","unreadCount","readNotification","unreadNotification","newNotification","changedNotifications","n","useNotificationStoresCollection$1","useMagicBellEvent","handler","useEffect","callback","args","RealtimeListener","collection","settings","apiKey","user","fetchAndResetAll","fetchAndPrependAll","markAllAsSeen","markAllAsRead","removeNotification","archiveNotification","unarchiveNotification","listen","setupXHR","_b","serverURL","userSettings","setupStores","storesConfig","defaults","MagicBellProvider","children","disableRealtime","useState","config","jsxs","Fragment","stringToUint8Array","plainString","padding","base64","rawData","outputArray","storeSubscription","subscription","subscribeToPushNotifications","pushManager","publicKey","applicationServerKey","createPushSubscription","vapidPublicKey","createSafariPushSubscription","authenticationToken","webServiceUrl","websitePushID","permissionData","resolve","reject","subscriptionData","WebPushNotificationsSubscriber","serviceWorkerPath","skipServiceWorkerRegistration","isSafari","isPushAPISupported","_c","registration","useNotifications","fetch","useCallback","fetchNextPage","page","markAllAsReadFn","markAllAsSeenFn","useBell","dayjs","localizedFormat","relativeTime","updateLocale","secondsToDate","seconds","toDate","date","toUnix","parseJSON","obj","e","useNotificationFactory","markNotificationAsRead","markNotificationAsSeen","markNotificationAsUnread","deleteNotification","markAsSeen","markAsRead","markAsUnread","deleteSelf","archive","unarchive","useNotificationUnmount","fn","useNotification","onUnmount","NotificationPreferencesRepository","payload","useNotificationPreferences","preferences","useNotificationPreferences$1"],"mappings":"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"}